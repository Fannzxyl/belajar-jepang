<!DOCTYPE html>
<html lang="id" data-theme="pastel" class="no-js">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <title>Pelatih Kana Jepang — v9</title>
    <meta name="description" content="Pelajari Hiragana & Katakana lengkap (dasar, dakuon/handakuon, youon) dengan tes & review, audio, Pomodoro, progress, tema pastel/kontras." />
    <meta name="theme-color" content="#7a6cff">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://alfan.github.io/kana-trainer/">
    <meta property="og:title" content="Pelatih Kana Jepang — v9">
    <meta property="og:description" content="Pelatih Kana Jepang v9 — latihan interaktif, audio pelafalan, tes adaptif, Pomodoro, progress, tema pastel/kontras. Progres tersimpan lokal. Mulai gratis sekarang.">
    <meta property="og:image" content="https://alfan.github.io/kana-trainer/kana-trainer-preview.png">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://alfan.github.io/kana-trainer/">
    <meta property="twitter:title" content="Pelatih Kana Jepang — v9">
    <meta property="twitter:description" content="Pelatih Kana Jepang v9 — latihan interaktif, audio pelafalan, tes adaptif, Pomodoro, progress, tema pastel/kontras. Progres tersimpan lokal. Mulai gratis sekarang.">
    <meta property="twitter:image" content="https://alfan.github.io/kana-trainer/kana-trainer-preview.png">

    <link rel="canonical" href="https://alfan.github.io/kana-trainer/">

    <!-- Favicon -->
    <link rel="icon" href="favicon.ico">
    <link rel="icon" type="image/svg+xml"
      href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><defs><linearGradient id='g' x1='0' y1='0' x2='1' y2='1'><stop stop-color='%237a6cff'/><stop offset='1' stop-color='%2316c6a1'/></linearGradient></defs><rect width='64' height='64' rx='14' fill='url(%23g)'/><text x='50%' y='54%' text-anchor='middle' font-family='Noto Sans JP,Arial' font-size='38' fill='white'>あ</text></svg>">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;700&family=Noto+Serif+JP:wght@700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        :root{
            --bg:#f8fbff; --panel:#ffffff; --soft:#f2f6ff; --ink:#132030; --muted:#76849c;
            --pri:#7a6cff; --sec:#16c6a1; --warn:#ff7b7b; --ok:#2fb875; --accent:#ffd166;
            --btn:#e9eefc; --btnText:#0b101a; --border:rgba(19,32,48,.10);
            --radius:18px; --shadow:0 6px 18px rgba(15,23,34,.08);
            --ring: 0 0 0 3px rgba(122,108,255,.28);
            --okBg:#dff4ea;
            --warnBg:#ffe5e5;
            --iconColor: var(--muted);
            --transition-duration: 0.2s; /* New: Default transition duration */

            /* UI/UX Mobile-First: Container & spacing */
            --space: 12px;
            --radius-clamp: 14px; /* Renamed to avoid conflict with --radius */
            --maxw: 760px; /* pas buat 720p */
        }
        [data-theme="hc"]{
            --bg:#0a0f1a; --panel:#0f1626; --soft:#0c1220; --ink:#e6efff; --muted:#9fb0cc;
            --pri:#8fa8ff; --sec:#3dd8b5; --warn:#ff8c8c; --ok:#7be0b3; --accent:#ffd98a;
            --btn:#18243a;
            --btnText:#e6efff;
            --border:rgba(230,239,255,.12);
            --ring: 0 0 0 3px rgba(143,168,255,.35);
            --okBg:#1a3a2e;
            --warnBg:#3a1a1a;
            --iconColor: var(--ink);
        }
        /* PATCH: Lite Mode styles */
        [data-lite="1"] {
            /* Disable heavy CSS */
            background: var(--bg) !important; /* Override radial gradients */
            /* backdrop-filter: none !important; */ /* Controlled explicitly on header */
            
            /* Reduce/disable box-shadow */
            --shadow: none !important; 
            box-shadow: none !important; /* Apply directly to elements if needed */

            /* Reduce transitions */
            --transition-duration: 0.05s !important;
            transition-duration: 0.05s !important;
        }

        [data-lite="1"] header {
            backdrop-filter: none !important;
        }

        [data-lite="1"] .card, [data-lite="1"] .kana, [data-lite="1"] .btn, [data-lite="1"] .seg {
            box-shadow: none !important;
        }
        
        *{box-sizing:border-box}
        html { height: auto; }
        body {
            min-height: 100svh;
            margin:0;
            font-family:'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background: radial-gradient(900px 420px at -10% -20%, rgba(122,108,255,.10), transparent),
                        radial-gradient(900px 420px at 110% -30%, rgba(22,198,161,.12), transparent),
                        var(--bg);
            color:var(--ink);
            /* PATCH: Smooth transitions for overall UI */
            transition: background-color var(--transition-duration) ease-out, color var(--transition-duration) ease-out;
            /* PATCH 6: Hilangkan overflow horizontal global */
            overflow-x: hidden; 
        }
        /* Override gradients if lite mode is active */
        [data-lite="1"] body {
            background: var(--bg) !important;
        }

        .wrap{
            max-width: 720px;
            margin: auto;
            padding: 16px;
            padding-left: calc(16px + env(safe-area-inset-left));
            padding-right: calc(16px + env(safe-area-inset-right));
        }
        /* UI/UX Mobile-First: Container */
        .container{ 
            width:100%; 
            max-width:var(--maxw); 
            margin-inline:auto; 
            padding: clamp(10px, 2vw, 16px); 
        }
        header{position:sticky;top:0;z-index:30;background:linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.72));backdrop-filter: blur(8px);border-bottom:1px solid var(--border); padding-top:env(safe-area-inset-top);
        transition: background var(--transition-duration) ease-out, backdrop-filter var(--transition-duration) ease-out, border-bottom-color var(--transition-duration) ease-out;}
        [data-theme="hc"] header{background:linear-gradient(180deg, rgba(15,22,38,.86), rgba(15,22,38,.66))}
        
        .brand{
            display:flex;
            align-items:center;
            gap:12px;
            justify-content: space-between;
            flex-wrap: wrap;
        }

        header .header-controls-row {
            margin-left: 0;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
            margin-top: 0;
            flex-basis: auto;
        }
        
        /* Main Navigation (now handled by JS router, but keeping styles for consistency) */
        .main-nav {
            width: 100%;
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid var(--border);
            display: none !important; /* Hide old main nav */
        }
        .main-nav .row {
            justify-content: center;
        }
        .main-nav .btn {
            flex-grow: 1;
        }
        @media (min-width: 768px) {
            .main-nav .btn {
                flex-grow: 0;
            }
        }


        @media (max-width: 767px) {
            header { position: static; } 
            .brand {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            header .header-controls-row {
                width: 100%;
                justify-content: flex-start;
                margin-top: 12px;
            }
            header .header-controls-row .seg,
            header .header-controls-row label,
            header .header-controls-row button {
                flex-grow: 1;
                min-width: unset;
            }
        }

        /* Logo positioning for header */
        /* Removed .header-logo-container CSS as per P1.3 */
        /* Adjust brand padding to make space for the logo */
        header .brand {
            padding-right: 60px; /* Make space for the logo on the right */
        }
        @media (max-width: 767px) {
            header .brand {
                padding-left: 16px; /* Reset padding for mobile if needed, or adjust */
            }
        }


        h1{font-size:20px;margin:0}
        .grid{display:grid;gap:14px;margin-top:16px}
        
        @media(min-width:768px){
            .wrap{max-width: 960px;}
            .grid{grid-template-columns:repeat(12,1fr)}
        }
        @media(min-width:1024px){
            .wrap{max-width: 1200px;}
        }

        /* UI/UX Mobile-First: Card */
        .card{ 
            grid-column:span 12;
            background:var(--panel);
            border-radius:var(--radius-clamp); /* Use new radius clamp variable */
            box-shadow: 0 4px 16px rgba(0,0,0,.2); /* Per instruction */
            padding: clamp(12px, 2vw, 16px); /* Per instruction */
            border:1px solid var(--border);
            transition: background-color var(--transition-duration) ease-out, border-color var(--transition-duration) ease-out, box-shadow var(--transition-duration) ease-out;
        }
        .card h2{font-size:16px;margin:0 0 10px 0; display: flex; align-items: center; gap: 8px;}
        .card h3{font-size:14px; margin: 16px 0 8px 0; color: var(--muted);}
        .card h2 .icon { color: var(--iconColor); transition: color var(--transition-duration) ease-out;}
        .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
        .btn{
            min-height:52px;
            padding: 0 16px;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all var(--transition-duration) ease-out;
            color: var(--ink);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-decoration: none; /* Additional for links */
        }
        .btn:active{transform:translateY(1px)}
        .btn.primary{
            background:linear-gradient(135deg, var(--pri), var(--sec));
            color:var(--btnText);
        }
        .btn.ok{
            background:var(--okBg);
            color:var(--ink);
        }
        .btn.warn{
            background:var(--warnBg);
            color:var(--ink);
        }
        .btn.ghost{background:transparent;outline:1px solid var(--border); color: var(--ink);}
        .btn:focus-visible{outline:none; box-shadow:var(--ring); outline-offset: 3px;}

        .seg{display:flex;border:1px solid var(--border);border-radius:12px;overflow:hidden; transition: border-color var(--transition-duration) ease-out;}
        .seg button{
            flex:1;
            background:var(--soft);
            border:none;
            padding: 12px 16px;
            font-size: 14px;
            cursor: pointer;
            transition: all var(--transition-duration) ease-out;
            color: var(--ink);
        }
        .seg button.active{background:linear-gradient(135deg, rgba(122,108,255,.18), rgba(22,198,161,.18))}
        [data-theme="hc"] .seg button.active{background:linear-gradient(135deg, rgba(143,168,255,.15), rgba(61,216,181,.15))}

        .pillbox{display:grid;grid-template-columns:repeat(4,1fr);gap:8px}
        @media(min-width:480px){.pillbox{grid-template-columns:repeat(5,1fr)}}
        @media(min-width:680px){.pillbox{grid-template-columns:repeat(6,1fr)}}
        
        .kana{
            min-height:88px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: var(--btn);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: all var(--transition-duration) ease-out;
            color: var(--ink);
        }
        .kana:active{transform:scale(.98)}
        .kana .jp{font-size:clamp(24px, 6vw, 30px);line-height:1}
        .kana .ro{
            font-size:12px;
            color:var(--muted);
        }
        .kana.mastered {
            background: linear-gradient(135deg, var(--okBg), rgba(47,184,117,.2));
            border-color: var(--ok);
            box-shadow: 0 0 0 2px var(--ok);
        }
        [data-theme="hc"] .kana.mastered {
            background: linear-gradient(135deg, var(--okBg), rgba(61,216,181,.1));
            box-shadow: 0 0 0 2px var(--ok);
        }

        .kana:focus-visible{outline:none; box-shadow:var(--ring)}

        .chips{
            display:flex;
            flex-wrap: wrap;
            gap:8px;
            padding-bottom: 0;
        }
        .chip{
            padding:8px 10px;
            border-radius:999px;
            background:var(--soft);
            border:1px solid var(--border);
            cursor:pointer;
            min-height:36px;
            white-space:nowrap; 
            transition: all var(--transition-duration) ease-out;
            color: var(--ink);
        }

        /* Responsive adjustments for subset chips (horizontal scroll) */
        /* Updated for sticky label */
        #subsetChips {
            position: relative; /* For sticky title */
            padding-top: 22px; /* Space for sticky title */
            display: flex;
            flex-wrap: nowrap; /* Prevent wrapping */
            overflow-x: auto; /* Enable horizontal scrolling */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            gap: 8px;
            padding-bottom: 6px; /* Space for scrollbar */
            scroll-snap-type: x proximity; /* Smooth snapping */
            justify-content: flex-start; /* Align items to the start */
            width: 100%; /* Ensure it takes full width */
        }
        #subsetChips .chips-title { /* New style for sticky title */
            position: absolute;
            left: 0;
            top: 0;
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap; /* Prevent title from wrapping */
        }
        #subsetChips .chip {
            flex: 0 0 auto; /* Prevent stretching, allow width based on content */
            width: auto; /* Let content define width */
            white-space: nowrap; /* Keep text on one line */
            scroll-snap-align: start;
        }
        /* Hide scrollbar for aesthetic, but keep functionality */
        #subsetChips::-webkit-scrollbar{ height: 8px; }
        #subsetChips::-webkit-scrollbar-thumb{ background: var(--border); border-radius: 999px; }


        /* --- NEW RESPONSIVE TEST CONTROLS (GRID-BASED) --- */

        /* 1. Baris chip + select-set + qType + answerMode */
        .test-controls-row{
            display:grid;
            grid-template-columns: 1fr; /* mobile: satu kolom */
            gap:8px;
            align-items:end;
        }
        @media (min-width:480px){
            .test-controls-row{ grid-template-columns: 1fr 1fr; }
        }
        @media (min-width:768px){
            .test-controls-row{ grid-template-columns: 1fr auto auto auto; }
        }

        /* 2. Kelompok “Jumlah soal” jadi Grid yang aman di HP */
        .test-control-group{
            display:grid;
            grid-template-columns: 1fr; /* tumpuk di HP */
            gap:8px;
            margin-top: var(--space); /* Add margin top for spacing */
        }
        @media (min-width:520px){
            /* label kecil | input angka | chips */
            .test-control-group{ grid-template-columns: auto 120px 1fr; align-items:center; }
        }
        /* Biar input nggak maksa melebar */
        .test-control-group > *{ min-width:0; }

        /* 3. Range khusus (rentang/grup tunggal) juga Grid */
        /* tag + 3–4 select */
        /* These are now applied directly to the selects within the grid context */
        #rangeMode, #testFrom, #testTo, #testSingleGroup{
            width:100%; min-width:0; pointer-events:auto; position:relative; z-index:1;
        }
        /* Styling for the new #rangeControls div */
        #rangeControls {
            display: grid;
            grid-template-columns: 1fr; /* Default to 1 column on mobile */
            gap: 8px;
            align-items: center;
        }
        @media (min-width:520px){
            #rangeControls {
                grid-template-columns: auto 1fr 1fr 1fr; /* tag + 3 kontrol */
            }
        }
        /* Hide element's parent if the element is hidden */
        #testSingleGroup[hidden] {
            display: none !important;
        }
        #testToWrap[hidden] {
            display: none !important;
        }


        /* 4. Amankan komponen “chips” supaya nggak dorong lebar */
        #countChips{
            display:flex; flex-wrap:wrap; gap:8px;
        }
        /* #subsetChips already handled above */
        @media (min-width:768px){
            #subsetChips{ display:flex; flex-wrap:nowrap; overflow-x:auto; }
        }

        /* 5. Form control benar-benar fleksibel */
        input, select, textarea { width:100%; min-width:0; }
        @media (max-width:480px){
            /* Hapus lebar fix di HP */
            #testCount, #sylPerItem { width:100% !important; }
        }
        /* Ikon panah pada <select> tidak menambah lebar */
        select{ background-origin:content-box; padding-right:36px; }

        /* 6. Tombol aksi Tes menumpuk rapi di HP */
        /* Baris Mulai/Lewati/Selesai */
        .row[style*="justify-content: center;"]{
            flex-wrap:wrap; gap:8px;
        }
        .row[style*="justify-content: center;"] .btn{ flex:1 1 140px; }

        /* --- END NEW RESPONSIVE TEST CONTROLS --- */

        /* UI/UX Mobile-First: Grid MC rapi & tombol konsisten */
        .mc-grid{
            display:grid; 
            gap: clamp(10px, 2vw, 14px);
            grid-template-columns: 1fr 1fr; /* 2 kolom di HP */
        }
        @media (min-width: 860px){ 
            .mc-grid{ grid-template-columns: repeat(4, 1fr); } 
        }
        .mc-btn{
            display:flex; align-items:center; justify-content:center;
            min-height: 52px; padding: 10px;
            border-radius: 12px; border: 1px solid #2a2a2a;
            background:#181818; color:#fff; text-align:center;
            line-height:1.2; font-size: clamp(14px, 3.8vw, 16px);
        }
        .mc-btn[aria-pressed="true"]{ outline:2px solid #6b8bff; }


        .center{text-align:center}
        .small{font-size:12px;color:var(--muted)}
        .tag{
            display:inline-block;padding:4px 8px;border-radius:999px;background:var(--soft);
            color:var(--ink);
            font-size:12px;border:1px solid var(--border);
            transition: background-color var(--transition-duration) ease-out, border-color var(--transition-duration) ease-out, color var(--transition-duration) ease-out;
        }

        .progress{height:10px;background:rgba(0,0,0,.08);border-radius:999px;overflow:hidden}
        .bar{height:100%;width:0;background:linear-gradient(90deg,var(--pri),var(--sec),var(--accent));transition:width var(--transition-duration) ease}

        /* PATCH: CSS Modal */
        .modal{
          position:fixed; inset:0;
          display:flex; align-items:center; justify-content:center;
          background: rgba(0,0,0,.45);
          z-index:999;
          opacity: 0;
          pointer-events: none;
          transition: opacity var(--transition-duration) ease-out;
        }
        .modal[hidden]{ display:none; }
        .modal.is-open { opacity:1; pointer-events:auto; }

        @supports (backdrop-filter: blur(6px)) {
            @media (min-width: 768px) {
                .modal{ background: rgba(0,0,0,.35); backdrop-filter: blur(6px); }
                /* PATCH: Lite Mode disables backdrop-filter */
                [data-lite="1"] .modal { backdrop-filter: none; }
            }
        }

        .modal .box{background:var(--panel);padding:20px 18px;border-radius:18px;box-shadow:var(--shadow);text-align:center;max-width:620px;width:min(92vw,620px);
        transition: background-color var(--transition-duration) ease-out, box-shadow var(--transition-duration) ease-out;}
        .burst{position:fixed;inset:0;pointer-events:none}
        .particle{position:absolute;width:8px;height:8px;border-radius:2px;opacity:.9;animation:pop 900ms ease forwards}
        @keyframes pop{from{transform:translate(0,0) scale(1)} to{transform:translate(var(--dx), var(--dy)) rotate(360deg) scale(0.8);opacity:0}}

        /* UI/UX Mobile-First: Ganti optwrap dengan mc-grid */
        .optwrap{ display: grid; gap: clamp(10px, 2vw, 14px); grid-template-columns: 1fr 1fr; max-width: 520px; margin: 0 auto; }
        @media(min-width:560px){ .optwrap{ grid-template-columns: repeat(4, 1fr); } }
        .optwrap .btn{ font-size: clamp(14px, 3.8vw, 16px); min-height: 52px; border-radius: 12px; } /* Consistent with .mc-btn */

        .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

        @media (max-width: 420px){ :root{ --radius:14px } .kana .jp{ font-size:56px !important } }

        @keyframes correctPop { 0%{transform:scale(1);background-color:transparent} 50%{transform:scale(1.1);background-color:var(--ok)} 100%{transform:scale(1);background-color:transparent} }
        @keyframes wrongShake { 0%,100%{transform:translateX(0);background-color:transparent} 25%{transform:translateX(-5px);background-color:var(--warn)} 75%{transform:translateX(5px);background-color:var(--warn)} }

        #qKana.correct-answer { animation: correctPop 0.3s ease-out }
        #qKana.wrong-answer { animation: wrongShake 0.3s ease-out }

        #streakCounter { font-size:14px; font-weight:600; color:var(--sec); margin-left:10px; min-width:50px; text-align:right; transition: transform var(--transition-duration) ease-out }
        @keyframes streakGrow { 0%{transform:scale(1)} 50%{transform:scale(1.2)} 100%{transform:scale(1)} }
        #streakCounter.grow { animation: streakGrow 0.2s ease-out }

        /* .spinner { display:none !important } */

        @media (prefers-reduced-motion: reduce){
            *{animation-duration:0.01ms !important; animation-iteration-count:1 !important; transition-duration:0.01ms !important; scroll-behavior:auto !important}
            #qKana.correct-answer, #qKana.wrong-answer, #streakCounter.grow { animation:none !important }
            .toast { transition: none !important; }
            /* PATCH: Lite Mode will also disable animations */
            [data-lite="1"] * {animation-duration:0.01ms !important; animation-iteration-count:1 !important; transition-duration:0.01ms !important; scroll-behavior:auto !important}
            [data-lite="1"] #qKana.correct-answer, [data-lite="1"] #qKana.wrong-answer, [data-lite="1"] .toast { transition: none !important; }
        }

        /* === Anti horizontal overflow global === */
        html, body {
            max-width: 100%;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }
        /* No-JS fallback */
        .no-js #main {
            display: block !important;
        }

        /* Ensure main containers don't over-expand */
        .wrap, main, header {
            width: 100%;
            max-width: 100%;
        }

        /* Safe grid: columns don't force expansion */
        @media (min-width: 768px) {
            .grid { grid-template-columns: repeat(12, minmax(0, 1fr)); }
        }

        /* Pillbox safe at all breakpoints */
        .pillbox { grid-template-columns: repeat(4, minmax(0, 1fr)); }
        @media (min-width:480px){ .pillbox{ grid-template-columns: repeat(5, minmax(0,1fr)); } }
        @media (min-width:680px){ .pillbox{ grid-template-columns: repeat(6, minmax(0,1fr)); } }

        /* Flex children can shrink (to prevent crowding and layout breaks) */
        .row > * { min-width: 0; }

        /* Header controls: prevent items from pushing width */
        .header-controls-row > * { min-width: 0; }

        /* Buttons/chips shouldn't have large min-width that causes overflow */
        .btn, .chip { max-width: 100%; }

        /* Form controls safe width */
        input, select, textarea { max-width: 100%; }

        /* Responsive canvas & media */
        img, video, svg { max-width: 100%; height: auto; display: block; }

        /* Modal & toast always use viewport, not overflowing document width */
        .modal { inset: 0; }
        /* PATCH: Ensure toast is always horizontally centered and safe width */
        .toast{
          position: fixed; /* Ensure it's fixed */
          left:50%;
          transform:translateX(-50%);
          max-width:calc(100vw - 24px);
          bottom: 20px; /* Consistent bottom position */
          padding: 10px 15px;
          border-radius: 8px;
          background-color: var(--okBg); /* Default info */
          color: var(--ink);
          box-shadow: var(--shadow);
          z-index: 1000;
          opacity: 0;
          transition: opacity var(--transition-duration) ease-in-out;
        }
        .toast.warn { background-color: var(--warnBg); } /* Warning specific color */


        /* Progress bar and segments don't expand container */
        .progress, .seg { max-width: 100%; }

        /* Fix select with background-icon so it's consistent */
        select{ background-origin:content-box; padding-right:36px; } /* Moved up for general application */


        /* PATCH: Desktop layout (≥1024px): Pomodoro & Tracker side by side */
        @media (min-width: 1024px) {
            main.wrap {
                display: grid;
                grid-template-columns: repeat(12, minmax(0, 1fr));
                gap: 14px;
            }
            /* Default: each section full-width */
            main.wrap > section { grid-column: span 12; }
            /* Specific: Pomodoro & Tracker 50:50 */
            #pomoSection { grid-column: span 6; }
            #trackerSection { grid-column: span 6; }
        }

        /* PATCH: Center subtitle "Hiragana • Katakana … Writer" */
        header .brand > div:nth-child(2){
          flex: 1 1 auto;
          text-align: center;
        }
        header .brand h1{ margin-bottom: 4px; }
        header .brand .small{ display:block; }

        /* New styles for sidebar */
        .sidebar {
            position: fixed;
            top: 0;
            left: -300px; /* Hidden by default */
            width: 280px;
            height: 100%;
            background: var(--panel);
            box-shadow: var(--shadow);
            z-index: 1000;
            transition: left 0.3s ease-in-out;
            padding: 20px;
            padding-top: calc(20px + env(safe-area-inset-top));
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            border-right: 1px solid var(--border);
        }

        .sidebar.is-open {
            left: 0;
        }

        .sidebar-toggle-btn {
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 1001; /* Above sidebar */
            background: var(--btn);
            border: 1px solid var(--border);
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow);
            transition: all 0.3s ease-in-out;
        }

        .sidebar-toggle-btn:hover {
            background: var(--soft);
        }

        .sidebar-toggle-btn i {
            color: var(--ink);
            font-size: 20px;
        }

        /* Adjust main content when sidebar is open on desktop */
        @media (min-width: 768px) {
            body.sidebar-open {
                padding-left: 280px;
            }
            .sidebar-toggle-btn {
                left: 16px; /* Stays on the left */
            }
            .sidebar.is-open + .sidebar-toggle-btn {
                left: 296px; /* Moves with the sidebar */
            }
        }

        /* Ensure header content is not hidden by sidebar toggle button */
        header .brand {
            position: relative;
            z-index: 1002;
            padding-left: 60px; /* Space for the toggle button */
        }
        @media (max-width: 767px) {
            header .brand {
                padding-left: calc(16px + env(safe-area-inset-left)); /* Reset padding for mobile if needed, or adjust */
            }
        }

        /* --- NEW CSS FOR SIDEBAR AND ROUTING --- */
        .sidebar .menu { list-style:none; margin:0; padding:0; }
        .sidebar .menu li a{
            display:flex; gap:.5rem; align-items:center;
            padding:.75rem 1rem; border-radius:12px;
            color: var(--ink); /* Ensure text color is correct */
            text-decoration: none; /* Remove underline */
            transition: background-color var(--transition-duration) ease-out;
        }
        .sidebar .menu li a:hover {
            background: var(--soft);
        }
        .sidebar .menu li a.active{ background:rgba(122,108,255,.12); font-weight:600; }
        @media (max-width:640px){
            .sidebar{ width:84vw; max-width:320px; }
        }
        [data-page][hidden]{ display:none !important; }
        [inert]{ pointer-events:none; user-select:none; }
        /* --- END NEW CSS FOR SIDEBAR AND ROUTING --- */

        /* Form look & feel */
        /* Updated: Applied to input, select, textarea, and specific input types */
        .input, select, textarea, input[type="number"], input[type="text"]{
            height:52px; padding:0 14px; border:1px solid var(--border);
            border-radius:12px; background:var(--panel); color:var(--ink);
            box-shadow: var(--shadow);
            transition: box-shadow var(--transition-duration) ease, border-color var(--transition-duration) ease, background var(--transition-duration) ease;
        }
        .input::placeholder{ color: var(--muted); }

        /* Focus ring */
        .input:focus, select:focus, textarea:focus, input[type="number"]:focus, input[type="text"]:focus{
            outline:none; box-shadow: var(--ring); border-color: transparent;
        }

        /* Number tidy (hapus spinner di mobile/Chromium) */
        input[type=number]::-webkit-outer-spin-button,
        input[type=number]::-webkit-inner-spin-button{ -webkit-appearance:none; margin:0; }
        input[type=number]{ -moz-appearance:textfield; }

        /* Select arrow padding sudah di CSS; tambahkan height konsisten */
        select{ height:52px; }

        /* UI Responsive 720p */
        /* Header container */
        header .brand > div:nth-child(2){
            display:flex; flex-wrap:wrap; align-items:center; gap:.5rem;
            flex: 1 1 auto;
            text-align: center;
        }
        header .brand h1{
            font-size: clamp(20px, 4.5vw, 28px);
            line-height:1.2;
            margin-bottom: 0; /* Remove default margin */
        }
        header .brand .tag {
            font-size: clamp(10px, 2.8vw, 12px);
            margin-left: 0.5rem; /* Space between title and badge */
        }
        header .brand .small {
            font-size: clamp(10px, 2.8vw, 12px);
            display: block; /* Ensure it stays on its own line */
            width: 100%; /* Take full width */
            margin-top: 4px; /* Space from title/badge */
        }

        /* Tombol besar (“Mulai Tes”, “Lewati”) */
        @media (max-width: 360px) {
            .row[style*="justify-content: center;"] .btn {
                width: 100%;
                flex: 1 1 auto; /* Allow buttons to grow and shrink */
            }
        }
        .btn {
            min-height: 44px; /* Apply min-height to all buttons */
        }

        /* Grid opsi MC */
        /* UI/UX Mobile-First: .mc-grid menggantikan .optwrap */
        .mc-grid{
            display:grid; 
            gap: clamp(10px, 2vw, 14px);
            grid-template-columns: 1fr 1fr; /* 2 kolom di HP */
            max-width: 520px; /* Tetap pertahankan agar tidak terlalu lebar di desktop */
            margin: 0 auto; /* Tengah */
        }
        @media (min-width: 560px){ /* Mengikuti breakpoint lama .optwrap */
            .mc-grid{ grid-template-columns: repeat(4, 1fr); } 
        }
        .mc-grid .btn{
            font-size: clamp(14px, 3.8vw, 16px); 
            min-height: 52px; 
            border-radius: 12px;
            /* Tambahan: Pastikan teks MC tidak terpotong */
            white-space: normal;
            word-break: break-word;
            padding: 8px 10px; /* Beri sedikit padding vertikal */
        }

        /* Card/section padding */
        .card {
            padding: clamp(10px, 3vw, 16px);
        }

        /* Sidebar FAB (tombol hamburger bulat) */
        .sidebar-toggle-btn {
            inset-inline-start: 8px; /* Equivalent to left */
            inset-block-start: 8px; /* Equivalent to top */
            z-index: 50; /* Lower z-index to avoid covering controls */
        }
        /* Adjust header padding for sidebar toggle button */
        header .brand {
            padding-left: calc(60px + env(safe-area-inset-left)); /* Make space for the toggle button */
        }
        @media (max-width: 767px) {
            header .brand {
                padding-left: calc(16px + env(safe-area-inset-left)); /* Reset padding for mobile if needed, or adjust */
            }
        }

        /* P2.6: Lite Mode - disable animations for feedback classes */
        [data-lite="1"] #qKana.correct-answer,
        [data-lite="1"] #qKana.wrong-answer,
        [data-lite="1"] #streakCounter.grow {
            animation: none !important;
        }

        /* UI/UX Mobile-First: Soal + audio tersusun */
        .question{
            display:flex; align-items:center; justify-content:center; /* Center the question and audio button */
            gap: 12px; padding: 8px 0;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        .q-char{ 
            font-size: clamp(36px, 10vw, 56px); /* Per instruction */
            font-weight:700; 
            line-height:1.2; /* Ensure line height is consistent */
            text-align: center; /* Center text */
            flex-grow: 1; /* Allow it to take available space */
            min-width: 0; /* Prevent overflow */
        }
        .btn-audio-current{
            width:44px; height:44px; border-radius:50%;
            display:grid; place-items:center; border:1px solid #2a2a2a; background:#181818;
            flex-shrink: 0; /* Prevent shrinking */
        }

        /* UI/UX Mobile-First: Navbar bawah yang sticky (opsional) */
        .bottom-bar{
            position: sticky; bottom: 0; left: 0; right: 0;
            padding: 10px; background: #0e0e0eE6; backdrop-filter: blur(6px);
            display:flex; gap:10px; justify-content: space-between;
            z-index: 40; /* Above main content, below modals */
        }
        .bottom-bar .btn{ flex:1; min-height:46px; border-radius:12px; }

    </style>
</head>
<body>
    <!-- Audio element untuk playKanaAudio -->
    <audio id="audio" preload="auto" style="display: none;"></audio>

    <!-- Sidebar Toggle Button -->
    <button id="sidebarToggle" class="sidebar-toggle-btn" aria-label="Toggle Sidebar">
        <i class="fa-solid fa-bars"></i>
    </button>

    <!-- Sidebar Content -->
    <nav id="sidebar" class="sidebar">
        <div class="row" style="justify-content: space-between; align-items: center;">
            <h3 style="margin:0;">Navigasi</h3>
            <button class="btn ghost" id="closeSidebar" aria-label="Tutup Sidebar">
                <i class="fa-solid fa-times"></i>
            </button>
        </div>
        <hr style="border: none; border-top: 1px solid var(--border); width: 100%;">
        <ul class="menu">
            <li><a href="index.html">🏡 Latihan</a></li>
            <li><a href="index2.html">🗂️ Flashcard</a></li>
            <li><a href="index3.html">🧮 Tabel Kana</a></li>
            <li><a href="index4.html">🗒️ Kosakata</a></li>
            <li><a href="index5.html">💬 Ungkapan</a></li>
            <li><a href="index7.html" onclick="closeSidebar()">🧠 Tebak Arti</a></li> <!-- New: Tebak Arti Link -->
            <li><a href="index6.html">✍️ Menulis</a></li>
        </ul>
    </nav>

    <header>
        <div class="wrap">
            <div class="brand">
                <svg class="logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="36" height="36">
                    <defs>
                        <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
                            <stop stop-color="#7a6cff"/><stop offset="1" stop-color="#16c6a1"/>
                        </linearGradient>
                    </defs>
                    <rect width="64" height="64" rx="14" fill="url(#g)"/>
                    <text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle"
                                font-family="Noto Sans JP, 'Noto Serif JP', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif"
                                font-size="38" fill="white" dy="-2">あ</text>
                    </svg>
                <div>
                    <h1>Pelatih Kana Jepang <span class="tag">v9</span></h1>
                    <div class="small">Dasar • Dakuon/Handakuon • Youon • Tes & Review • Pomodoro • Tema</div>
                </div>
                <div class="row header-controls-row" style="gap:6px">
                    <div class="seg" role="tablist" aria-label="Tema">
                        <button id="tPastel" class="btn" role="tab" aria-selected="true" type="button" title="Tema pastel">Pastel</button>
                        <button id="tHC" class="btn" role="tab" aria-selected="false" type="button" title="Tema high-contrast">Kontras Tinggi</button>
                    </div>
                    <label class="btn ghost" style="display:flex;align-items:center;gap:8px">
                        <input id="audToggle" type="checkbox" aria-label="Suara efek & pelafalan" /> Suara (efek & pelafalan)
                    </label>
                    <label class="btn ghost" id="liteModeToggleBtn" style="display:flex;align-items:center;gap:8px">
                        <input id="liteToggle" type="checkbox" aria-label="Mode Ringan" /> Lite Mode
                    </label>
                    <button id="exportBtn" class="btn ghost" type="button" title="Simpan progres ke file"><i class="fa-solid fa-download"></i> Simpan Progres ke File</button>
                    <input type="file" id="importFile" accept=".json" style="display:none;" aria-label="Pulihkan progres dari file">
                    <button id="importBtn" class="btn ghost" type="button" title="Pulihkan progres dari file"><i class="fa-solid fa-upload"></i> Pulihkan Progres dari File</button>
                    <button id="resetBtn" class="btn ghost" type="button" title="Atur ulang semua progres">Atur Ulang Semua</button>
                </div>
            </div>
            <!-- NAVIGASI UTAMA (LAMA - TERSEMBUNYI) -->
            <nav class="main-nav">
                <div class="row">
                    <a href="index.html" class="btn primary"><i class="fa-solid fa-home"></i> Latihan</a>
                    <a href="index2.html" class="btn ghost"><i class="fa-solid fa-clone"></i> Flashcard</a>
                    <a href="index3.html" class="btn ghost"><i class="fa-solid fa-table"></i> Tabel Kana</a>
                    <a href="index4.html" class="btn ghost"><i class="fa-solid fa-book-open"></i> Kosakata</a>
                    <a href="index5.html" class="btn ghost"><i class="fa-solid fa-comments"></i> Ungkapan</a>
                    <a href="index7.html" class="btn ghost"><i class="fa-solid fa-brain"></i> Tebak Arti</a> <!-- New: Tebak Arti Link -->
                    <a href="index6.html" class="btn ghost"><i class="fa-solid fa-pen"></i> Menulis</a>
                </div>
            </nav>
        </div>
    </header>

    <main class="wrap" id="main" style="display: none;">
        <!-- ==== LATIHAN (gabungan: Belajar + Tes + Pomodoro + Tracker) ==== -->
        <section id="page-latihan" data-page>
            <!-- CTA Card for Tebak Arti -->
            <div class="card" style="grid-column:span 12;">
                <h2><i class="fa-solid fa-brain icon"></i> Tebak Arti (JP→ID)</h2>
                <div class="small">Kuis arti Jepang → Indonesia (A–D). Pilih kategori & jumlah soal.</div>
                <div class="row" style="justify-content:flex-start; margin-top: var(--space);">
                    <a class="btn primary" href="index7.html"><i class="fa-solid fa-play"></i> Mulai Tebak Arti</a>
                    <a class="btn ghost" href="index7.html#kategori"><i class="fa-solid fa-list"></i> Pilih Kategori</a>
                </div>
            </div>

            <!-- Subbagian A: Belajar rentang kana -->
            <div id="latihan-belajar" class="grid">
                <div class="card" style="grid-column: span 12;">
                    <h2 id="learnTitle"><i class="fa-solid fa-book icon"></i> Belajar (Pilih Rentang Kana)</h2>
                    <div class="small">Pilih set (Hiragana/Katakana) dan rentang fleksibel. Ketuk tile untuk dengar pelafalan.</div>
                    <div class="spacer"></div>
                    <div class="row">
                        <select id="learnSet" class="input" aria-label="Pilih set belajar">
                            <option value="hira">Hiragana</option>
                            <option value="kata">Katakana</option>
                        </select>
                        <select id="fromGrp" class="input" aria-label="Dari kelompok"></select>
                        <select id="toGrp" class="input" aria-label="Sampai kelompok"></select>
                        <button class="btn primary" id="btnShowLearn" type="button"><i class="fa-solid fa-eye"></i> Tampilkan</button>
                    </div>
                    <div class="spacer"></div>
                    <div id="learnTiles" class="pillbox" aria-live="polite">
                        <!-- Empty state for Learn Mode -->
                        <div class="small" style="grid-column: span 4; text-align: center;">Pilih set & rentang dulu, lalu tekan Tampilkan.</div>
                    </div>
                </div>
            </div>

            <!-- Subbagian B: Tes (ketik/MCQ) -->
            <div id="latihan-tes" class="grid">
                <div class="card" style="grid-column: span 12;">
                    <h2 id="testTitle"><i class="fa-solid fa-pencil-alt icon"></i> Tes</h2>
                    <div class="small">
                        Pilih set, tipe & mode soal, lalu jumlah soal. Kamu bisa juga pilih rentang atau grup spesifik.
                    </div>
                    <div class="spacer"></div>

                    <div class="row test-controls-row">
                        <!-- Updated: subsetChips now has a sticky label -->
                        <div id="subsetChips">
                            <div class="chips-title">Pilih cepat:</div>
                            <button class="chip" data-preset="aiueo-m" type="button">aiueo → m</button>
                            <button class="chip" data-preset="base-all" type="button">Dasar semua</button>
                            <button class="chip" data-preset="dakuon-all" type="button">Dakuon</button>
                            <button class="chip" data-preset="youon-all" type="button">Youon</button>
                            <button class="chip" data-preset="jft-drill" type="button">JFT Drill</button> <!-- Preset JFT Drill -->
                            <!-- Original chips will be added by JS renderAll -> buildSubsetChips() -->
                        </div>
                        <select id="testSet" class="input" aria-label="Pilih set tes">
                            <option value="hira">Hiragana</option>
                            <option value="kata">Katakana</option>
                        </select>
                        <select id="qType" class="input" title="Tipe Soal" aria-label="Tipe soal">
                            <option value="k2r">Kana → Romaji</option>
                            <option value="r2k">Romaji → Kana (Pilihan Ganda)</option>
                            <option value="seq">Rangkaian Romaji → Kana</option>
                            <option value="audio_k2r">Listening (Dengar Kana → Romaji)</option>
                            <option value="audio_r2k">Listening (Dengar Romaji → Kana)</option>
                            <option value="kseq">Kana Sequence (Ketik Romaji)</option>
                        </select>
                        <select id="answerMode" class="input" aria-label="Mode jawaban">
                            <option value="type">Mode Ketik</option>
                            <option value="mc">Pilihan Ganda (A–D)</option>
                        </select>
                    </div>

                    <div class="spacer"></div>
                    <div class="row test-control-group">
                        <div class="tag" style="align-self: center;">Jumlah soal:</div>
                        <input id="testCount" class="input" type="number" min="1" value="10" aria-label="Jumlah soal" />
                        <div class="chips" id="countChips">
                            <button class="chip" data-count="10" type="button">10</button>
                            <button class="chip" data-count="25" type="button">25</button>
                            <button class="chip" data-count="50" type="button">50</button>
                            <button class="chip" data-count="100" type="button">100</button>
                        </div>
                    </div>
                    <div class="row test-control-group" id="sylPerItemControl" hidden>
                        <div class="tag">Suku kata/soal:</div>
                        <input id="sylPerItem" class="input" type="number" min="2" max="6" value="3" aria-label="Jumlah suku kata per soal" />
                    </div>
                    <div class="spacer"></div>
                    <!-- Updated: Changed class to ID for specific styling -->
                    <div id="rangeControls" class="test-control-group">
                        <div class="tag">Atau rentang khusus:</div>
                        <select id="rangeMode" class="input" aria-label="Mode rentang">
                            <option value="range">Rentang</option>
                            <option value="single">Grup Tunggal</option>
                        </select>
                        <select id="testFrom" class="input" aria-label="Tes dari"></select>
                        <div id="testToWrap"><select id="testTo" class="input" aria-label="Tes sampai"></select></div>
                        <select id="testSingleGroup" class="input" aria-label="Pilih Grup"></select> <!-- Removed hidden attribute here, visibility handled by JS -->
                        <div class="small" style="grid-column: span 4; text-align: center; margin-top: 4px;">Jika 'Dari' > 'Sampai', sistem akan menukar otomatis.</div>
                    </div>
                    <div class="spacer"></div>
                    <div class="row" style="justify-content: center;">
                        <button class="btn primary" id="btnStart" type="button" title="Gunakan Enter untuk Cek, → untuk Lewati"><i class="fa-solid fa-play"></i> Mulai Tes</button>
                        <button class="btn" id="btnSkip" type="button" title="Lewati soal (→)"><i class="fa-solid fa-forward"></i> Lewati</button>
                        <button class="btn warn" id="btnEnd" type="button"><i class="fa-solid fa-stop"></i> Selesai</button>
                    </div>

                    <div class="spacer"></div>
                    <div class="progress" aria-label="Progress Tes" role="progressbar" aria-valuemin="0" aria-valuemax="100"><div id="bar" class="bar"></div></div>
                    <div class="spacer"></div>
                    <div id="testArea" class="center" hidden>
                        <!-- UI/UX Mobile-First: Soal + audio tersusun -->
                        <div id="promptWrap" class="question">
                            <div id="qKana" class="q-char">あ</div>
                            <button class="btn-audio-current" type="button" title="Putar lagi audio" aria-label="Putar ulang audio" data-kana=""><i class="fa-solid fa-volume-up"></i></button>
                        </div>
                        <div id="typeWrap" style="max-width:520px;margin:0 auto">
                            <input id="ans" class="input" placeholder="Ketik jawaban kamu di sini…" autocomplete="off" autocapitalize="none" autocorrect="off" spellcheck="false" inputmode="text" aria-label="Jawaban" />
                            <div class="spacer"></div>
                            <button class="btn" id="btnCheck" type="button"><i class="fa-solid fa-check"></i> Cek (Enter)</button>
                        </div>
                        <!-- UI/UX Mobile-First: Menggunakan class mc-grid -->
                        <div id="mcWrap" class="mc-grid" hidden>
                            <button class="btn opt mc-btn" id="optA" aria-label="Pilihan A" title="Pilihan A" type="button">A</button>
                            <button class="btn opt mc-btn" id="optB" aria-label="Pilihan B" title="Pilihan B" type="button">B</button>
                            <button class="btn opt mc-btn" id="optC" aria-label="Pilihan C" title="Pilihan C" type="button">C</button>
                            <button class="btn opt mc-btn" id="optD" aria-label="Pilihan D" title="Pilihan D" type="button">D</button>
                            <div class="small" style="grid-column: span 2; text-align: center; margin-top: 4px;">Ketuk atau tekan A/B/C/D</div>
                        </div>
                        <div class="spacer"></div>
                        <div class="small" id="testInfo" aria-live="polite">
                            <span id="testInfoText"></span>
                            <span id="streakCounter">Streak: 0</span>
                        </div>
                    </div>
                    <div id="testEmptyState" class="small" style="text-align: center; margin-top: 16px;">Setel tipe soal dan jumlah, lalu tekan Mulai Tes.</div>
                </div>
            </div>

            <!-- Subbagian C: Pomodoro mini -->
            <div id="pomoSection" class="grid">
                <div class="card">
                    <h2 id="pomoTitle"><i class="fa-solid fa-clock icon"></i> Timer Pomodoro (Opsional)</h2>
                    <div class="small">Default 25/5, bisa diubah. Status dan sisa waktu tersimpan otomatis.</div>
                    <div class="row" role="group" aria-label="Kontrol Pomodoro">
                        <label>
                            <span class="sr-only">Menit fokus</span>
                            <input id="pomoWork" class="input" type="number" min="1" value="25"> menit fokus
                        </label>
                        <label>
                            <span class="sr-only">Menit istirahat</span>
                            <input id="pomoBreak" class="input" type="number" min="1" value="5"> menit istirahat
                        </label>
                        <button class="btn primary" id="pStart" type="button"><i class="fa-solid fa-play"></i> Mulai</button>
                        <button class="btn" id="pPause" type="button"><i class="fa-solid fa-pause"></i> Pause</button>
                        <button class="btn warn" id="pReset" type="button" aria-label="Reset Pomodoro"><i class="fa-solid fa-redo"></i> Reset</button>
                    </div>
                    <div class="spacer"></div>
                    <div class="center">
                        <div id="pomoLabel" class="tag" aria-live="polite">Fokus</div>
                        <div id="pomoTime" style="font-size:32px;margin-top:6px">25:00</div>
                    </div>
                </div>
            </div>

            <!-- Subbagian D: Tracker/Progres -->
            <div id="trackerSection" class="grid">
                <div class="card">
                    <h2 id="trackTitle"><i class="fa-solid fa-chart-line icon"></i> Tracker Kana</h2>
                    <div class="small">Ketuk untuk tandai sudah hafal. Tahan (long-press) untuk batal.</div>
                    <div class="spacer"></div>
                    <div class="row">
                        <div style="flex:1;min-width:280px">
                            <div class="muted">Hiragana</div>
                            <div id="hiraBox" class="pillbox"></div>
                        </div>
                        <div style="flex:1;min-width:280px">
                            <div class="muted">Katakana</div>
                            <div id="kataBox" class="pillbox"></div>
                        </div>
                    </div>
                    <div class="spacer"></div>
                    <div class="row">
                        <div class="tag" id="jpStats" aria-live="polite">0/104 hira • 0/104 kata</div>
                        <div class="tag" id="reviewDueIndicator" aria-live="polite" hidden>Review due: 0</div>
                    </div>
                    <div class="spacer"></div>
                    <div class="row" style="justify-content: center; font-size: 14px;">
                        <span id="totalPointsDisplay">Poin: 0</span>
                        <span style="margin: 0 10px;">•</span>
                        <span id="levelDisplay">Level: 1 (Pemula Kana)</span>
                    </div>
                    <div class="spacer"></div>
                    <div class="row" style="justify-content:center;">
                        <button class="btn warn" id="resetConfusionBtn" type="button" aria-label="Atur ulang log pasangan tertukar">Reset Confusion</button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Placeholder halaman lain -->
        <section id="page-flashcard" data-page hidden>
            <div class="card">
                <h2>🗂️ Flashcard</h2>
                <p>Konten untuk Flashcard akan ditampilkan di sini.</p>
                <div class="small">Ini adalah halaman placeholder.</div>
            </div>
        </section>
        <section id="page-tabel" data-page hidden>
            <div class="card">
                <h2>🧮 Tabel Kana</h2>
                <p>Konten untuk Tabel Kana akan ditampilkan di sini.</p>
                <div class="small">Ini adalah halaman placeholder.</div>
            </div>
        </section>
        <section id="page-kosakata" data-page hidden>
            <div class="card">
                <h2>🗒️ Kosakata</h2>
                <p>Konten untuk Kosakata akan ditampilkan di sini.</p>
                <div class="small">Ini adalah halaman placeholder.</div>
            </div>
        </section>
        <section id="page-ungkapan" data-page hidden>
            <div class="card">
                <h2>💬 Ungkapan</h2>
                <p>Konten untuk Ungkapan akan ditampilkan di sini.</p>
                <div class="small">Ini adalah halaman placeholder.</div>
            </div>
        </section>
        <section id="page-menulis" data-page hidden>
            <div class="card">
                <h2>✍️ Menulis</h2>
                <p>Konten untuk latihan menulis Kana akan ditampilkan di sini.</p>
                <div class="small">Ini adalah halaman placeholder.</div>
            </div>
        </section>

    </main>

    <!-- Celebration Modal / Review -->
    <div id="celebrate" class="modal" aria-modal="true" role="dialog" aria-labelledby="celebrateTitle" aria-describedby="celebrateMsg" hidden>
        <div class="box">
            <h3 id="celebrateTitle" style="margin:0 0 6px 0">Tes selesai! 🎉</h3>
            <div id="celebrateMsg" class="small">Skor: 0/0</div>
            <div class="spacer"></div>
            <div id="reviewWrap" style="text-align:left;max-height:40vh;overflow:auto;margin:8px 0" hidden></div>
            <div class="row" style="justify-content:center">
                <button class="btn" id="btnReviewWrong" hidden type="button"><i class="fa-solid fa-redo-alt"></i> Belajar ulang yang salah</button>
                <button class="btn primary" id="btnCloseModal" type="button" aria-label="Lanjut"><i class="fa-solid fa-times"></i> Lanjut</button>
            </div>
            <div id="burst" class="burst" aria-hidden="true"></div>
        </div>
    </div>

    <!-- Onboarding Modal -->
    <div id="onboardingModal" class="modal" aria-modal="true" role="dialog"
       aria-labelledby="onboardingTitle" aria-describedby="onboardingMsg" hidden>
        <div class="box">
            <h3 id="onboardingTitle" style="margin:0 0 6px 0">Selamat Datang di Pelatih Kana Jepang! 👋</h3>
            <div id="onboardingMsg" class="small">
                <p>Aplikasi ini akan membantumu menguasai Hiragana & Katakana.</p>
                <p><b>1. Belajar:</b> Pilih set & rentang, ketuk huruf buat dengar pelafalan.</p>
                <p><b>2. Tes:</b> Atur tipe soal (Kana → Romaji, Romaji → Kana, atau Rangkaian) & jumlah soal. Kamu bisa ketik atau pilih jawaban.</p>
            </div>
            <div class="spacer"></div>
            <div class="row" style="justify-content:center">
                <button class="btn primary" id="btnStartLearningOnboarding" type="button">Mulai Belajar!</button>
            </div>
        </div>
    </div>

    <!-- UI/UX Mobile-First: Bottom Bar (Opsional) -->
    <!-- <div class="bottom-bar">
        <button class="btn primary">Beranda</button>
        <button class="btn">Tes Cepat</button>
        <button class="btn">Progres</button>
    </div> -->

    <script>
        // --- Helpers aman ---
        const isNode = el => el && (el.nodeType === 1 || el.nodeType === 9); // ELEMENT_NODE atau DOCUMENT_NODE

        const qs = (sel, root = document) => (isNode(root) ? root.querySelector(sel) : null);

        const qsa = (sel, root = document) => {
            if (!isNode(root)) {
                // console.warn('qsa(): root bukan DOM node', sel, root); // Opsional: untuk debugging
                return [];
            }
            return Array.from(root.querySelectorAll(sel));
        };

        // Helper bind dan on juga diperbarui untuk menggunakan qs/qsa yang baru
        const bind = (sel, ev, fn, el=document) => qsa(sel, el).forEach?.(n => n.addEventListener(ev, fn, { passive: true }));
        const on = (sel, ev, fn, el=document) => { const n = qs(sel, el); if (n) n.addEventListener(ev, fn); };
        
        // No-JS Fallback: Remove 'no-js' class and show #main if JS is enabled
        document.documentElement.classList.remove('no-js');
        // Initial display for #main will be handled by renderAll -> showOnboarding, so we don't need a direct style here
        // qs('#main').style.display = '';

        /**
         * Escapes HTML entities in a string to prevent XSS.
         * @param {string} str - The string to escape.
         * @returns {string} The escaped string.
         */
        function escapeHTML(str){
            return String(str)
                .replaceAll('&','&amp;')
                .replaceAll('<','&lt;')
                .replaceAll('>','&gt;')
                .replaceAll('"','&quot;')
                .replaceAll("'",'&#39;');
        }

        // ---------- GLOBAL COPY / TEXTS ----------
        const copy = {
            nav_learn: 'Belajar',
            nav_test: 'Tes',
            nav_tracker: 'Tracker',
            nav_timer: 'Timer',
            btn_show: 'Tampilkan',
            btn_start_test: 'Mulai Tes',
            btn_check: 'Cek Jawaban',
            btn_skip: 'Lewati',
            btn_end: 'Selesai',
            empty_learn: 'Pilih set & rentang dulu, lalu tekan Tampilkan.',
            empty_test: 'Setel tipe soal, jumlah, dan rentang/grup, lalu tekan Mulai Tes.',
            empty_review: 'Bersih! Nggak ada jawaban keliru. 😊',
            done_test_title: 'Tes selesai! 🎉',
            done_test_sub: (s,t)=>`Skor kamu ${s}/${t}. Bagus!`,
            wrong_tip_dzu: 'Ingat:ぢ = dji (ji), づ = dzu (zu).', // Specific tip for dji/dzu
            confirm_reset_title: 'Atur ulang semua progres?',
            confirm_reset_sub: 'Tindakan ini tidak bisa dibatalkan.',
            import_ok: 'Impor progres berhasil!',
            import_fail: 'Ups, file-nya nggak cocok. Pastikan kamu pilih file progres yang benar (JSON).',
            export_ok: 'Progres berhasil diekspor sebagai kana-progress.json!',
            level_up_title: (level)=>`Level Up! 🎉 Level ${level}!`,
            level_up_msg: (name)=>`Kamu sekarang seorang ${name}! Terus semangat! 🔥`,
            // PATCH: Character fix in streak_title
            streak_title: 'Wii! Keren banget! ✨',
            streak_msg: '10 jawaban benar berturut-turut. Lanjutkan momentummu! ✨',
            pomo_focus: 'Fokus',
            pomo_break: 'Istirahat',
            pomo_start_focus: (time)=>`Fokus dimulai. ${time} — semangat!`,
            pomo_time_break: 'Waktunya istirahat. Minum air dulu 🥤',
            test_info_text: (set, range, qType, total, target)=>`${set} • ${range} • ${qType} • Soal ${total}/${target}`,
            test_streak: (streak)=>`Streak: ${streak}`,
            test_mc_hint: 'Ketuk atau tekan A/B/C/D',
            learn_tile_tooltip: 'Ketuk untuk dengar, tahan untuk batal',
            onboarding_title: 'Selamat Datang di Pelatih Kana Jepang! 👋',
            onboarding_step1: '<b>1. Belajar:</b> Pilih set & rentang, ketuk huruf buat dengar pelafalan.',
            onboarding_step2: '<b>2. Tes:</b> Atur tipe soal (Kana → Romaji, Romaji → Kana, atau Rangkaian) & jumlah soal. Kamu bisa ketik atau pilih jawaban.',
            onboarding_button_start: 'Mulai Belajar!',
            feedback_correct: (kana, romaji) => `Mantap! ${kana} = ${romaji} ✅`,
            feedback_wrong: (kana, romaji, user_input) => `Belum pas. ${kana} dibaca ${romaji}. Jawaban kamu: ${user_input}. Coba lagi ya.`,
            feedback_wrong_dji_dzu: (kana, romaji, user_input) => `Belum pas. ${kana} dibaca ${romaji} (boleh juga ji/zu). Jawaban kamu: ${user_input}. Coba lagi ya.`,
            feedback_skipped: 'Oke, kita lanjut dulu.',
            confuse_train_label: 'Latih Pasangan Tertukar',
            review_today_label: 'Review Hari Ini',
            replay_audio: 'Putar lagi',
            no_due_today: 'Tidak ada item review hari ini.',
            syl_per_item: 'Suku kata/soal',
            reset_confusion: 'Reset Confusion',
            review_due_count: (count) => `Review due: ${count}`,
            test_type_k2r: 'Kana → Romaji',
            test_type_r2k: 'Romaji → Kana',
            test_type_seq: 'Rangkaian Romaji → Kana',
            test_type_audio_k2r: 'Listening (Dengar Kana → Romaji)',
            test_type_audio_r2k: 'Listening (Dengar Romaji → Kana)',
            test_type_kseq: 'Kana Sequence (Ketik Romaji)',
            lite_mode_on: 'Mode Ringan AKTIF!',
            lite_mode_off: 'Mode Ringan NONAKTIF!',
            all_kana_label: 'Semua Kana',
            jft_drill_label: 'JFT Drill',
        };

        const t = (key, ...args) => {
            let text = copy[key] || `MISSING_COPY_KEY: ${key}`;
            if (typeof text === 'function') {
                return text(...args);
            }
            return text;
        };

        // ---------- STATE ----------
        const KEY = 'kanaTrainer_v9';
        const initState = () => ({
            theme:'pastel',
            audio:false,
            hiraMastered:[], kataMastered:[],
            test:{
                subset:'all', set:'hira', mode:'type', qType:'k2r', // subset default to 'all'
                score:0, total:0, correctStreak:0, target:10, rangeMode:'range', // rangeMode default
                sylPerItem: 3,
                rangeFrom: 'aiueo', // Default values for range selects
                rangeTo: 'n',
                singleGroup: 'aiueo'
            },
            pomo:{mode:'work', work:25, break:5, remaining:25*60, running:false, last:0},
            totalPoints: 0,
            level: 1,
            hasSeenOnboarding: false,
            confusionLog:{ hira:{}, kata:{} },
            srs:{ boxes:{}, due:{} },
            lite: false,
        });
        let state = load();
        let _saveTimer = null;
        function load(){
            try{
                const raw=localStorage.getItem(KEY);
                const loadedState = raw ? JSON.parse(raw) : initState();
                const mergedState = { ...initState(), ...loadedState };
                mergedState.test = deepMerge(initState().test, loadedState.test);
                mergedState.pomo = deepMerge(initState().pomo, loadedState.pomo);
                mergedState.hasSeenOnboarding = loadedState.hasSeenOnboarding !== undefined ? loadedState.hasSeenOnboarding : initState().hasSeenOnboarding;
                mergedState.confusionLog = deepMerge(initState().confusionLog, loadedState.confusionLog);
                mergedState.srs = deepMerge(initState().srs, loadedState.srs);
                mergedState.lite = loadedState.lite !== undefined ? loadedState.lite : initState().lite;
                return mergedState;
            }catch(e){
                console.error("Error loading state from localStorage:", e);
                return initState();
            }
        }
        function save(){
            clearTimeout(_saveTimer);
            _saveTimer=setTimeout(()=>{
                try{ localStorage.setItem(KEY, JSON.stringify(state)); }
                catch(e){ console.error("Error saving state to localStorage:", e); }
            }, 150);
        }

        function deepMerge(target, source) {
            for (const key in source) {
                if (source.hasOwnProperty(key)) {
                    if (typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key]) && typeof target[key] === 'object' && target[key] !== null && !Array.isArray(target[key])) {
                        target[key] = deepMerge(target[key] || {}, source[key]);
                    } else {
                        target[key] = source[key];
                    }
                }
            }
            return target;
        }

        // ---------- DATA ----------
        const BASE = ['a','i','u','e','o','ka','ki','ku','ke','ko','sa','shi','su','se','so','ta','chi','tsu','te','to','na','ni','nu','ne','no','ha','hi','fu','he','ho','ma','mi','mu','me','mo','ya','yu','yo','ra','ri','ru','re','ro','wa','wo','n'];
        const DAKUON = [
            'ga','gi','gu','ge','go',
            'za','ji','zu','ze','zo',
            'da','dji','dzu','de','do',
            'ba','bi','bu','be','bo','pa','pi','pu','pe','po'
        ];
        const YOUON = ['kya','kyu','kyo','sha','shu','sho','cha','chu','cho','nya','nyu','nyo','hya','hyu','hyo','mya','myu','myo','rya','ryu','ryo','gya','gyu','gyo','ja','ju','jo','bya','byu','byo','pya','pyu','pyo'];

        const HIRA_BASE = ['あ','い','う','え','お','か','き','く','け','こ','さ','し','す','せ','そ','た','ち','つ','て','と','な','に','ぬ','ね','の','は','ひ','ふ','へ','ほ','ま','み','む','め','も','や','ゆ','よ','ら','り','る','れ','ろ','わ','を','ん'];
        const KATA_BASE = ['ア','イ','ウ','エ','オ','カ','キ','ク','ケ','コ','サ','シ','ス','セ','ソ','タ','チ','ツ','テ','ト','ナ','ニ','ヌ','ネ','ノ','ハ','ヒ','フ','ヘ','ホ','マ','ミ','ム','メ','モ','ヤ','ユ','ヨ','ラ','リ','ル','レ','ロ','ワ','ヲ','ン'];

        const HIRA_DAKU = ['が','ぎ','ぐ','げ','ご','ざ','じ','ず','ぜ','ぞ','だ','ぢ','づ','で','ど','ば','び','ぶ','べ','ぼ','ぱ','ぴ','ぷ','ぺ','ぽ'];
        const KATA_DAKU = ['ガ','ギ','グ','ゲ','ゴ','ザ','ジ','ズ','ゼ','ゾ','ダ','ヂ','ヅ','デ','ド','バ','ビ','ブ','ベ','ボ','パ','ピ','プ','ペ','ポ'];

        const HIRA_YOU = ['きゃ','きゅ','きょ','しゃ','しゅ','しょ','ちゃ','ちゅ','ちょ','にゃ','にゅ','にょ','ひゃ','ひゅ','ひょ','みゃ','みゅ','みょ','りゃ','りゅ','りょ','ぎゃ','ぎゅ','ぎょ','じゃ','じゅ','じょ','びゃ','びゅ','びょ','ぴゃ','ぴゅ','ぴょ'];
        const KATA_YOU = ['キャ','キュ','キョ','シャ','シュ','ショ','チャ','チュ','チョ','ニャ','ニュ','ニョ','ヒャ','ヒュ','ヒョ','ミャ','ミュ','ミョ','リャ','リュ','リョ','ギャ','ギュ','ギョ','ジャ','ジュ','ジョ','ビャ','ビュ','ビョ','ピャ','ピュ','ピョ'];

        const GROUPS = [
            {key:'aiueo', label:'a i u e o', list:BASE, idx:[0,1,2,3,4]},
            {key:'k', label:'ka ki ku ke ko', list:BASE, idx:[5,6,7,8,9]},
            {key:'s', label:'sa shi su se so', list:BASE, idx:[10,11,12,13,14]},
            {key:'t', label:'ta chi tsu te to', list:BASE, idx:[15,16,17,18,19]},
            {key:'n', label:'na ni nu ne no', list:BASE, idx:[20,21,22,23,24]},
            {key:'h', label:'ha hi fu he ho', list:BASE, idx:[25,26,27,28,29]},
            {key:'m', label:'ma mi mu me mo', list:BASE, idx:[30,31,32,33,34]},
            {key:'y', label:'ya yu yo', list:BASE, idx:[35,36,37]},
            {key:'r', label:'ra ri ru re ro', list:BASE, idx:[38,39,40,41,42]},
            {key:'w', label:'wa wo n', list:BASE, idx:[43,44,45]},
            {key:'g', label:'ga gi gu ge go', list:DAKUON, idx:[0,1,2,3,4]},
            {key:'z', label:'za ji zu ze zo', list:DAKUON, idx:[5,6,7,8,9]},
            {key:'d', label:'da dji dzu de do', list:DAKUON, idx:[10,11,12,13,14]},
            {key:'b', label:'ba bi bu be bo', list:DAKUON, idx:[15,16,17,18,19]},
            {key:'p', label:'pa pi pu pe po', list:DAKUON, idx:[20,21,22,23,24]},
            {key:'ky', label:'kya kyu kyo', list:YOUON, idx:[0,1,2]},
            {key:'sh', label:'sha shu sho', list:YOUON, idx:[3,4,5]},
            {key:'ch', label:'cha chu cho', list:YOUON, idx:[6,7,8]},
            {key:'ny', label:'nya nyu nyo', list:YOUON, idx:[9,10,11]},
            {key:'hy', label:'hya hyu hyo', list:YOUON, idx:[12,13,14]},
            {key:'my', label:'mya myu myo', list:YOUON, idx:[15,16,17]},
            {key:'ry', label:'rya ryu ryo', list:YOUON, idx:[18,19,20]},
            {key:'gy', label:'gya gyu gyo', list:YOUON, idx:[21,22,23]},
            {key:'j',  label:'ja ju jo', list:YOUON, idx:[24,25,26]},
            {key:'by', label:'bya byu byo', list:YOUON, idx:[27,28,29]},
            {key:'py', label:'pya pyu pyo', list:YOUON, idx:[30,31,32]},
        ];

        const HIRA_MAP = new Map();
        const KATA_MAP = new Map();
        BASE.forEach((r,i)=>{HIRA_MAP.set(r,HIRA_BASE[i]);KATA_MAP.set(r,KATA_BASE[i])});
        DAKUON.forEach((r,i)=>{HIRA_MAP.set(r,HIRA_DAKU[i]);KATA_MAP.set(r,KATA_DAKU[i])});
        YOUON.forEach((r,i)=>{HIRA_MAP.set(r,HIRA_YOU[i]);KATA_MAP.set(r,KATA_YOU[i])});

        const ALL_ROMAJI = [...new Set([...BASE,...DAKUON,...YOUON])];
        const ROMAJI_SORTED = [...ALL_ROMAJI].sort((a,b)=>b.length-a.length);

        const CONFUSE_KATA = [
            ['シ','ツ'], ['ソ','ン'], ['ク','ケ'], ['フ','ワ'], ['ヂ','ジ'], ['ヅ','ズ'],
            ['ノ','メ'], ['イ','リ'], ['エ','ヱ'], ['ネ','レ'], ['ア','マ'], ['ム','厶']
        ];
        const CONFUSE_HIRA = [
            ['ぬ','め'], ['れ','ne'], ['う','ra'], ['ち','sa'], ['つ','te'], ['ヲ','wa'] // Fixed: 'ヲ' for 'wo'
        ];
        
        function similarChoicesKata(correct){
            for(const g of CONFUSE_KATA) {
                if(g.includes(correct)) {
                    return g.filter(x=>x!==correct);
                }
            }
            return [];
        }
        function similarChoicesHira(correct) {
            for(const g of CONFUSE_HIRA) {
                if(g.includes(correct)) {
                    return g.filter(x=>x!==correct);
                }
            }
            return [];
        }

        // Leitner SRS Intervals (in seconds)
        const SRS_INTERVAL = {
            1: 0,      // Box 1: Immediate repeat
            2: 86400,  // Box 2: 1 day
            3: 3 * 86400, // Box 3: 3 days
            4: 7 * 86400, // Box 4: 7 days
            5: 14 * 86400 // Box 5: 14 days
        };

        function getDueReviewItems(set) {
            const now = Math.floor(Date.now() / 1000);
            const dueItems = [];
            for (const romaji in state.srs.due) {
                if (state.srs.due[romaji] <= now) {
                    const char = (set === 'hira' ? HIRA_MAP : KATA_MAP).get(romaji);
                    if (char) {
                        dueItems.push({ romaji, char });
                    }
                }
            }
            return dueItems;
        }


        // ---------- UI HELPERS ----------
        const df = ()=>document.createDocumentFragment();

        // ---------- TRACKER ----------
        function buildKana(boxId, set){
            const box = qs('#'+boxId); box.innerHTML='';
            const rom = ALL_ROMAJI; const map = set==='hira'? HIRA_MAP: KATA_MAP; const mastered = set==='hira'? state.hiraMastered: state.kataMastered;
            const frag=df();
            rom.forEach(r=>{
                const ch = map.get(r);
                const b = document.createElement('button'); b.type='button';
                b.className='kana' + (mastered.includes(r) ? ' mastered' : '');
                b.innerHTML=`<div class="jp">${escapeHTML(ch)}</div><div class="ro">${escapeHTML(r)}</div>`; // Escape kana/romaji
                b.title=t('learn_tile_tooltip');
                // PATCH: Gunakan ttsSpeak untuk tile pembelajaran
                b.onclick=()=> ttsSpeak(ch, 'ja-JP'); 
                attachLongPress(b, () => toggleMaster(r, set), () => uncheck(r, set));
                frag.appendChild(b);
            });
            box.appendChild(frag);
        }
        function toggleMaster(label, set){
            const arr=(set==='hira'?state.hiraMastered:state.kataMastered);
            const i=arr.indexOf(label);
            if(i<0) {
                arr.push(label);
                state.totalPoints += 5;
                checkLevelUp();
            } else {
                state.totalPoints = Math.max(0, state.totalPoints - 5);
            }
            save();
            renderStats();
            buildKana(set==='hira'?'hiraBox':'kataBox', set);
            updatePointsAndLevelDisplay();
        }
        function uncheck(label,set){
            const arr=(set==='hira'?state.hiraMastered:state.kataMastered);
            const i=arr.indexOf(label);
            if(i>-1){
                arr.splice(i,1);
                state.totalPoints = Math.max(0, state.totalPoints - 5);
                save();
                renderStats();
                buildKana(set==='hira'?'hiraBox':'kataBox', set);
                updatePointsAndLevelDisplay();
            }
        }
        function renderStats(){ 
            qs('#jpStats').textContent = `${state.hiraMastered.length}/${ALL_ROMAJI.length} hira • ${state.kataMastered.length}/${ALL_ROMAJI.length} kata`; 
            const dueCount = getDueReviewItems('hira').length + getDueReviewItems('kata').length; // Check both sets
            const reviewDueIndicator = qs('#reviewDueIndicator');
            if (reviewDueIndicator) {
                reviewDueIndicator.textContent = t('review_due_count', dueCount);
                reviewDueIndicator.hidden = (dueCount === 0);
            }
        }

        // Gamification: Leveling system
        const LEVEL_THRESHOLDS = [0, 100, 250, 500, 1000, 2000, 3500, 5000, 7500, 10000];
        const LEVEL_NAMES = ["Pemula Kana", "Pengenal Kana", "Penyelidik Kana", "Penjelajah Kana", "Master Kana", "Sensei Kana", "Grandmaster Kana", "Kana Legendaris", "Dewa Kana", "Kana Abadi"];

        function getLevelAndThreshold(points) {
            let level = 1;
            let threshold = LEVEL_THRESHOLDS[0];
            let nextThreshold = LEVEL_THRESHOLDS[1] || Infinity;

            for (let i = 0; i < LEVEL_THRESHOLDS.length; i++) {
                if (points >= LEVEL_THRESHOLDS[i]) {
                    level = i + 1;
                    threshold = LEVEL_THRESHOLDS[i];
                    nextThreshold = LEVEL_THRESHOLDS[i + 1] || Infinity;
                } else {
                    break;
                }
            }
            return { level, threshold, nextThreshold };
        }

        function checkLevelUp() {
            const { level: oldLevel } = getLevelAndThreshold(state.totalPoints - 1); 
            const { level: newLevel } = getLevelAndThreshold(state.totalPoints);

            if (newLevel > oldLevel) {
                state.level = newLevel;
                save();
                maybeCelebrate('levelUp', newLevel); 
            }
        }

        function updatePointsAndLevelDisplay() {
            const totalPointsDisplay = qs('#totalPointsDisplay');
            const levelDisplay = qs('#levelDisplay');
            if (totalPointsDisplay) totalPointsDisplay.textContent = `Poin: ${state.totalPoints}`;
            if (levelDisplay) {
                const { level, nextThreshold } = getLevelAndThreshold(state.totalPoints);
                const currentLevelName = LEVEL_NAMES[level - 1] || `Level ${level}`;
                let progressText = '';
                if (nextThreshold !== Infinity) {
                    const pointsCurrentLevel = state.totalPoints - (LEVEL_THRESHOLDS[level - 1] || 0);
                    const pointsNeededForNext = nextThreshold - (LEVEL_THRESHOLDS[level - 1] || 0);
                    if (pointsNeededForNext > 0) {
                        progressText = ` (${pointsCurrentLevel}/${pointsNeededForNext})`;  
                    } else { // Should not happen if thresholds are well-defined
                        progressText = ``;  
                    }
                } else {
                    progressText = ` (MAX)`;
                }
                levelDisplay.textContent = `Level: ${level} ${currentLevelName}${progressText}`;
            }
        }

        // ---------- LEARN MODE ----------
        function fillLearnRange(){ const fromSel=qs('#fromGrp'), toSel=qs('#toGrp'); fromSel.innerHTML=''; toSel.innerHTML=''; GROUPS.forEach(g=>{ const o1=new Option(g.label,g.key); const o2=new Option(g.label,g.key); fromSel.add(o1); toSel.add(o2); }); fromSel.value='aiueo'; toSel.value='k'; }
        function startLearn(){
            const set=qs('#learnSet').value;
            const from=qs('#fromGrp').value, to=qs('#toGrp').value;
            const labels = rangeLabels(from,to);
            const map = set==='hira'?HIRA_MAP:KATA_MAP;
            const mastered = set==='hira'? state.hiraMastered: state.kataMastered;
            const box=qs('#learnTiles');
            box.innerHTML='';
            if(!labels.length){
                box.innerHTML=`<div class="small" style="grid-column: span 4; text-align: center;">${t('empty_learn')}</div>`;
                return;
            }
            const frag=df();
            labels.forEach(r=>{
                const ch = map.get(r);
                const tile=document.createElement('button');
                tile.type='button';
                tile.className='kana' + (mastered.includes(r) ? ' mastered' : '');
                tile.innerHTML=`<div class="jp">${escapeHTML(ch)}</div><div class="ro">${escapeHTML(r)}</div>`; // Escape kana/romaji
                tile.title=t('learn_tile_tooltip');
                // PATCH: Gunakan ttsSpeak untuk tile pembelajaran
                tile.onclick=()=> ttsSpeak(ch, 'ja-JP'); 
                attachLongPress(tile, () => toggleMaster(r, set), () => uncheck(r, set));
                frag.appendChild(tile);
            });
            box.appendChild(frag);
        }

        // ---------- TEST MODE ----------
        let testPool=[], poolIdx=[], usingRange=false, qIndex=0, currentItem=null, mcMap={}, wrongList=[];

        // --- Utils aman ---
        const AUDIO_TYPES = new Set(['audio_k2r','audio_r2k']);

        function isMCActive() {
            const area = qs('#testArea');
            const mode = qs('#answerMode')?.value || (window.state?.test?.mode);
            return !!area && !area.hidden && mode === 'mc';
        }
        const keyToOptIndex = (k) => {
            const s = String(k).toLowerCase();
            if (s==='a'||s==='1') return 0;
            if (s==='b'||s==='2') return 1;
            if (s==='c'||s==='3') return 2;
            if (s==='d'||s==='4') return 3;
            return -1;
        };

        // --- Audio: utilitas playKanaAudio (langsung ke <audio> element) ---
        function getAudioSrcForKana(kana) {
            // Placeholder: Implementasi ini harus sesuai dengan aset audio Anda
            // Contoh: './audio/hira/a.mp3'
            // Anda perlu memiliki folder 'audio' dengan subfolder 'hira' dan 'kata',
            // serta file audio untuk setiap karakter.
            const set = state.test.set; // 'hira' atau 'kata'
            if (!kana) return '';

            // Map kana ke romaji untuk mendapatkan nama file
            let romaji = '';
            for (let [key, value] of HIRA_MAP) {
                if (value === kana) {
                    romaji = key;
                    break;
                }
            }
            if (!romaji) {
                for (let [key, value] of KATA_MAP) {
                    if (value === kana) {
                        romaji = key;
                        break;
                    }
                }
            }
            if (!romaji) return ''; // Tidak ditemukan romaji yang cocok

            // Sesuaikan path file audio Anda di sini
            // Contoh: './audio/hira/a.mp3'
            // Jika ada dakuon/youon yang punya file khusus, sesuaikan
            let audioFileName = romaji;
            if (romaji === 'dji' && set === 'hira') audioFileName = 'dji_hira'; // Contoh penamaan khusus
            if (romaji === 'dzu' && set === 'hira') audioFileName = 'dzu_hira';
            if (romaji === 'dji' && set === 'kata') audioFileName = 'dji_kata';
            if (romaji === 'dzu' && set === 'kata') audioFileName = 'dzu_kata';

            return `./audio/${set}/${audioFileName}.mp3`; // Sesuaikan path jika berbeda
        }

        function playKanaAudio(kana) {
            if (!kana) return;
            const audioEl = document.getElementById('audio') || (() => {
                const a = document.createElement('audio'); a.id = 'audio'; document.body.appendChild(a); return a;
            })();

            const src = getAudioSrcForKana(kana);
            if (!src) return; 
            if (audioEl.src !== src) {
                audioEl.src = src;
                audioEl.load(); // Memastikan audio dimuat ulang jika src berubah
            }
            audioEl.currentTime = 0;
            audioEl.play().catch(()=>{ /* biarkan silent jika browser blokir sebelum user interaction */ });
        }

        // --- Audio: Dipanggil tombol audio di UI: ---
        function bindAudioButtonToCurrent() {
            const btn = document.querySelector('.btn-audio-current');
            if (!btn) return;

            // Hapus event listener sebelumnya untuk menghindari duplikasi
            // (Ini penting jika bindAudioButtonToCurrent dipanggil berulang)
            const oldClickHandler = btn.onclick;
            if (oldClickHandler) {
                btn.removeEventListener('click', oldClickHandler);
            }

            btn.onclick = (e) => {
                e.preventDefault();
                // Pastikan ambil kana soal saat ini:
                const kana = (window.currentItem && window.currentItem.char) 
                          || (window.currentItem && window.currentItem.kanaSeq && window.currentItem.kanaSeq[0]) 
                          || btn.dataset.kana 
                          || '';
                playKanaAudio(kana);
            };

            // Set data-kana di tombol saat ini untuk fallback
            const currentKana = (window.currentItem && window.currentItem.char) 
                               || (window.currentItem && window.currentItem.kanaSeq && window.currentItem.kanaSeq[0]) 
                               || '';
            btn.dataset.kana = currentKana;
        }


        // --- TTS minimal aman untuk mobile (tetap dipertahankan untuk fleksibilitas) ---
        function ttsSpeak(text, lang = 'ja-JP') {
            if (!text || !('speechSynthesis' in window)) return;
            // Taat toggle suara
            const audioOn = qs('#audToggle')?.checked ?? true;
            if (!audioOn) return;

            try {
                const u = new SpeechSynthesisUtterance(text);
                u.lang = lang; u.rate = 0.9; u.pitch = 1.0;
                window.speechSynthesis.cancel();
                window.speechSynthesis.speak(u);
            } catch(e) { console.warn('TTS error:', e); }
        }
        // kadang daftar voice baru ready setelah event ini
        window.speechSynthesis?.addEventListener?.('voiceschanged', () => { /* no-op */ });

        function getReplayTextForCurrentQuestion() {
            // Ambil tipe & data aktif dari state/DOM
            const qType = qs('#qType')?.value || window.state?.test?.qType || '';
            const cur = (window.state?.test?.current) || window.currentQuestion || currentItem || {};
            const kana = (cur.char || cur.kanaSeq || qs('#qKana')?.textContent || '').trim();
            const romaji = (cur.romaji || cur.romajiSeq || '').trim();

            const isR2K = /r2k/i.test(qType);
            
            if (isR2K) return romaji || kana;         // romaji → kana: bacakan romaji
            return kana || romaji || ''; // default: bacakan kana
        }

        function playCurrentQuestionAudio() {
            // Taat toggle suara
            const audioOn = qs('#audToggle')?.checked ?? true;
            if (!audioOn) return;

            const qType = qs('#qType')?.value || window.state?.test?.qType || '';
            const text = getReplayTextForCurrentQuestion();
            // Gunakan suara Jepang meskipun teks romaji — terdengar lebih natural untuk jp
            ttsSpeak(text, 'ja-JP');
        }

        // Set window._speak untuk kompatibilitas dengan bagian lain (mis. renderReview)
        window._speak = (text) => ttsSpeak(text, 'ja-JP');


        function _pairKey(a, b) {
            const [x, y] = [a, b].sort();
            return x + '|' + y;
        }

        function _confuseTopPairs(set, N = 10) {
            const log = state.confusionLog[set] || {};
            const pairs = Object.entries(log)
                .sort(([, countA], [, countB]) => countB - countA)
                .slice(0, N)
                .flatMap(([pairStr]) => pairStr.split('|'));
            return [...new Set(pairs)];
        }

        // ====== RENTANG KHUSUS (SELECTS) ======
        const elRangeMode = document.getElementById('rangeMode');
        const elFrom      = document.getElementById('testFrom');
        const elTo        = document.getElementById('testTo');
        const elSingle    = document.getElementById('testSingleGroup');
        const elToWrap    = document.getElementById('testToWrap');

        // helper isi <select>
        function fillOptions(select, items){
            if (!select) return; // Add null check
            select.innerHTML = '';
            for(const it of items){
                const opt = document.createElement('option');
                opt.value = it.key;            // 'aiueo','m','ky',dst.
                opt.textContent = it.label;    // 'a i u e o', 'ma mi mu me mo', dst.
                select.appendChild(opt);
            }
        }

        function populateRangeSelects(){
            // Urutan ikut index GROUPS → ini penting buat potong rentang
            fillOptions(elFrom, GROUPS);
            fillOptions(elTo,    GROUPS);
            fillOptions(elSingle, GROUPS);

            // restore saved values or set default safe values
            if (state.test.rangeFrom && elFrom && elFrom.querySelector(`option[value="${state.test.rangeFrom}"]`)) {
                elFrom.value = state.test.rangeFrom;
            } else if (elFrom) {
                elFrom.selectedIndex = 0;
                state.test.rangeFrom = elFrom.value;
            }

            if (state.test.rangeTo && elTo && elTo.querySelector(`option[value="${state.test.rangeTo}"]`)) {
                elTo.value = state.test.rangeTo;
            } else if (elTo) {
                elTo.selectedIndex = GROUPS.length - 1;
                state.test.rangeTo = elTo.value;
            }

            if (state.test.singleGroup && elSingle && elSingle.querySelector(`option[value="${state.test.singleGroup}"]`)) {
                elSingle.value = state.test.singleGroup;
            } else if (elSingle) {
                elSingle.selectedIndex = 0;
                state.test.singleGroup = elSingle.value;
            }
            
            // Set range mode
            if (state.test.rangeMode && elRangeMode && elRangeMode.querySelector(`option[value="${state.test.rangeMode}"]`)) {
                elRangeMode.value = state.test.rangeMode;
            } else if (elRangeMode) {
                elRangeMode.value = 'range'; // Default to 'range'
                state.test.rangeMode = 'range';
            }
            save(); // Save initial state
        }
        // populateRangeSelects(); // Call this in renderAll

        // toggle enable/disable + visibilitas
        function setEnabled(el, on){
            if (el) {
                el.disabled = !on;
                // Removed opacity/pointer-events, using 'inert' attribute and 'hidden' instead for better accessibility
                if (!on) {
                    el.setAttribute('inert', '');
                    el.hidden = true;
                } else {
                    el.removeAttribute('inert');
                    el.hidden = false;
                }
            }
        }

        // Updated function name from applyRangeMode to updateRangeUI as requested
        function updateRangeUI(){
            if (!elRangeMode) return; // Ensure element exists

            const mode = elRangeMode.value; // 'range' | 'single'
            state.test.rangeMode = mode; // Save current mode
            save(); // Save state immediately when rangeMode changes

            // Disable/hide range controls if a special subset (all, confusion, srs_due, jft-drill) is active
            const isSpecialSubsetActive = (state.test.subset === 'all' || state.test.subset === 'confusion' || state.test.subset === 'srs_due' || state.test.subset === 'jft-drill' || GROUPS.some(g => g.key === state.test.subset));

            if (isSpecialSubsetActive) {
                setEnabled(elRangeMode, false);
                setEnabled(elFrom, false); 
                setEnabled(elTo, false);
                if (elToWrap) elToWrap.hidden = true; 
                setEnabled(elSingle, false); 
            } else if(mode === 'range'){
                setEnabled(elRangeMode, true);
                setEnabled(elFrom, true); 
                setEnabled(elTo, true);
                if (elToWrap) elToWrap.hidden = false; // Show the wrapper for elTo
                setEnabled(elSingle, false); 
            }else if(mode === 'single'){
                setEnabled(elRangeMode, true);
                setEnabled(elFrom, false); 
                setEnabled(elTo, false);
                if (elToWrap) elToWrap.hidden = true; // Hide the wrapper for elTo
                setEnabled(elSingle, true); 
            }
            ensureValidRange(); // Ensure range is valid after UI update
            updateTestInfo(); // Update test info text
        }


        function ensureValidRange() {
            if (!elFrom || !elTo || elFrom.hidden || elTo.hidden) return; // Only validate if range is visible

            const fromKey = elFrom.value;
            const toKey = elTo.value;
            const order = GROUPS.map(g=>g.key);
            
            const fromIndex = order.indexOf(fromKey);
            const toIndex = order.indexOf(toKey);

            if (fromIndex > toIndex) {
                // Auto-swap biar gak "gabisa diklik"
                elFrom.value = toKey;
                elTo.value = fromKey;
                state.test.rangeFrom = toKey;
                state.test.rangeTo = fromKey;
                save(); // Save the swapped values
            } else {
                state.test.rangeFrom = fromKey;
                state.test.rangeTo = toKey;
                save(); // Save current valid values
            }
            updateTestInfo(); // Update test info text
        }


        bind('#rangeMode','change', updateRangeUI); // Bind to updated function name
        bind('#testFrom','change', ensureValidRange);
        bind('#testTo','change', ensureValidRange);
        bind('#testSingleGroup', 'change', (e) => {
            state.test.singleGroup = e.target.value;
            save();
            updateTestInfo();
        });

        // Ambil daftar romaji dari 1 group
        function romajiFromGroup(g){
            // g.list menunjuk BASE/DAKUON/YOUON, g.idx indeks romaji di list tsb.
            return g.idx.map(i => g.list[i]);
        }

        /**
         * Mengembalikan array romaji final untuk pool tes berdasarkan state.test.subset atau state.test.rangeMode.
         * Mempertimbangkan UI rentang ketika tidak ada chip subset khusus yang aktif.
         * @returns {string[]} Array of romaji labels.
         */
        function getChosenSubset(){
            // 1) chip khusus
            if (state.test.subset === 'all') {
                return ALL_ROMAJI;
            }
            if (state.test.subset === 'confusion') {
                return _confuseTopPairs(state.test.set);
            }
            if (state.test.subset === 'srs_due') {
                return getDueReviewItems(state.test.set).map(it => it.romaji);
            }
            if (state.test.subset === 'jft-drill') {
                // Rentang kana umum (aiueo → ra/ro, plus dakuon dasar)
                const jftGroups = GROUPS.filter(g => 
                    (g.key >= 'aiueo' && g.key <= 'r') || // aiueo -> ra/ri/ru/re/ro
                    (g.key === 'g' || g.key === 'z' || g.key === 'd') // ga-go, za-zo, da-do
                );
                return jftGroups.flatMap(g => romajiFromGroup(g));
            }

            // 2) ELSE (tidak ada chip khusus) – gunakan state.test.rangeMode
            if (state.test.rangeMode === 'range') {
                const labels = rangeLabels(state.test.rangeFrom, state.test.rangeTo);
                return labels.length > 0 ? labels : ALL_ROMAJI; // Fallback if result is empty
            }
            if (state.test.rangeMode === 'single') {
                const singleGroup = GROUPS.find(g => g.key === state.test.singleGroup);
                if (singleGroup) {
                    const labels = romajiFromGroup(singleGroup);
                    return labels.length > 0 ? labels : ALL_ROMAJI; // Fallback if result is empty
                }
                return ALL_ROMAJI; // Fallback if single group not found
            }

            // Fallback jika subset tidak cocok dengan kondisi di atas
            return ALL_ROMAJI;
        }

        // Moved buildSubsetChips definition here to ensure it's defined before renderAll
        function buildSubsetChips(){
            const box=qs('#subsetChips');
            // Preserve the chips-title div
            const existingTitle = box.querySelector('.chips-title');
            if (existingTitle) {
                box.innerHTML = ''; // Clear only chips, keep title
                box.appendChild(existingTitle);
            } else {
                 box.innerHTML=''; // Fallback if title not found
                const hint = document.createElement('div');
                hint.className = 'chips-title'; // Use new class for sticky
                hint.textContent = 'Pilih cepat:';
                box.appendChild(hint);
            }

            const frag=df();
            // Add "All Kana" chip
            const allKanaChip = document.createElement('button');
            allKanaChip.type = 'button';
            allKanaChip.className = 'chip' + (state.test.subset === 'all' ? ' active' : '');
            allKanaChip.setAttribute('aria-pressed', state.test.subset === 'all');
            allKanaChip.textContent = t('all_kana_label');
            allKanaChip.onclick = () => { 
                state.test.subset = 'all'; 
                // state.test.rangeMode = 'range'; // Reset to range, then hide via updateRangeUI
                save(); 
                buildSubsetChips(); 
                updateRangeUI(); // This will effectively hide range selects for 'all' or 'confusion' etc.
            };
            frag.appendChild(allKanaChip);

            // QUICK_PRESETS chips
            // Filter out 'jft-drill' from QUICK_PRESETS as it's added explicitly
            for (const key in QUICK_PRESETS) {
                if (key === 'jft-drill') continue; // Skip JFT drill here
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'chip';
                button.textContent = key.replace(/-/g, ' → ');
                button.dataset.preset = key;
                button.onclick = () => applyPreset(key);
                frag.appendChild(button);
            }
            
            // Add JFT Drill chip separately to ensure it's always there
            const jftDrillChip = document.createElement('button');
            jftDrillChip.type = 'button';
            jftDrillChip.className = 'chip' + (state.test.subset === 'jft-drill' ? ' active' : '');
            jftDrillChip.setAttribute('aria-pressed', state.test.subset === 'jft-drill');
            jftDrillChip.textContent = t('jft_drill_label');
            jftDrillChip.onclick = () => {
                state.test.subset = 'jft-drill';
                save();
                buildSubsetChips();
                updateRangeUI();
            };
            frag.appendChild(jftDrillChip);


            // Add "Train Confused Pairs" chip
            const confuseChip = document.createElement('button');
            confuseChip.type = 'button';
            confuseChip.className = 'chip' + (state.test.subset === 'confusion' ? ' active' : '');
            confuseChip.setAttribute('aria-pressed', state.test.subset === 'confusion');
            confuseChip.textContent = t('confuse_train_label');
            confuseChip.onclick = () => { 
                state.test.subset = 'confusion'; 
                // state.test.rangeMode = 'range'; // Reset to range, then hide via updateRangeUI
                save(); 
                buildSubsetChips(); 
                updateRangeUI(); 
            };
            frag.appendChild(confuseChip);

            // Add "Review Today" chip
            const reviewChip = document.createElement('button');
            reviewChip.type = 'button';
            reviewChip.className = 'chip' + (state.test.subset === 'srs_due' ? ' active' : '');
            reviewChip.setAttribute('aria-pressed', state.test.subset === 'srs_due');
            reviewChip.textContent = t('review_today_label');
            reviewChip.onclick = () => { 
                state.test.subset = 'srs_due'; 
                // state.test.rangeMode = 'range'; // Reset to range, then hide via updateRangeUI
                save(); 
                buildSubsetChips(); 
                updateRangeUI(); 
            };
            frag.appendChild(reviewChip);

            box.appendChild(frag);
        }

        /**
         * Memulai tes dengan logika subset/rentang yang diperbarui.
         * Membaca set/mode/qType/target seperti biasa.
         * Memanggil getChosenSubset() untuk mendapatkan label.
         * Membangun uniquePoolItems dari labels dan mengisi testPool.
         */
        function startTest(){
            wrongList=[];
            const set=qs('#testSet').value; state.test.set=set;
            const mode=qs('#answerMode').value; state.test.mode=mode;
            const qType=qs('#qType').value; state.test.qType=qType;
            // state.test.rangeMode is already updated by updateRangeUI on change
            const req = Math.max(1, parseInt(qs('#testCount').value,10)||10);
            
            // 1. Panggil getChosenSubset() untuk mendapatkan label
            let labels = getChosenSubset(); 

            // 2. Membangun uniquePoolItems dari labels (filter char yang undefined)
            let uniquePoolItems = labels.map(r => ({ romaji: r, char: (set === 'hira' ? HIRA_MAP : KATA_MAP).get(r) }));
            uniquePoolItems = uniquePoolItems.filter(item => item.char !== undefined); // Filter out items that don't have a corresponding Kana

            if(!uniquePoolItems.length){ 
                showCustomAlert('Tidak ada item untuk subset ini. Pakai chip "Semua Kana" ya.'); 
                return; 
            }

            // 3. Mengisi testPool dengan shuffle uniquePoolItems dan mengulang sampai jumlah `req` terpenuhi.
            testPool = [];
            let currentUniqueItems = [...uniquePoolItems];
            shuffle(currentUniqueItems);
            testPool = testPool.concat(currentUniqueItems);

            if (req > uniquePoolItems.length) {
                while (testPool.length < req) {
                    let shuffledRepeat = [...uniquePoolItems]; // Perbaikan spread operator
                    shuffle(shuffledRepeat);
                    testPool = testPool.concat(shuffledRepeat);
                }
                testPool = testPool.slice(0, req);
            }
            
            // poolIdx masih perlu untuk buildPoolLabels jika digunakan oleh makeSequence/makeKanaSequence (sekali lagi, ini diubah)
            // Namun, karena buildPoolLabels juga di-refactor, poolIdx kemungkinan tidak lagi diperlukan.
            // Untuk jaga-jaga, kita set saja agar tidak error.
            poolIdx = labels.map(r=> ALL_ROMAJI.indexOf(r)).filter(x=>x>=0);

            state.test.target = req;
            state.test.score=0; state.test.total=0; state.test.correctStreak=0; qIndex=0; save();
            qs('#testArea').hidden=false;
            qs('#testArea').style.opacity = '0'; // Start invisible
            qs('#testArea').style.pointerEvents = 'none'; // Disable interaction during transition
            qs('#testArea').style.transition = 'opacity var(--transition-duration) ease-out'; // Transition for opacity
            qs('#testEmptyState').hidden = true;
            
            // Clear any active state on MC buttons from previous tests
            qsa('#mcWrap .btn.opt').forEach?.(btn => btn.classList.remove('active'));

            setTimeout(() => {
                qs('#testArea').style.opacity = '1';
                qs('#testArea').style.pointerEvents = 'auto';
            }, 10); // Small delay to trigger transition

            updateProgress();
            nextQ();
        }

        function toggleAnswerUI(){
            const typeWrap = qs('#typeWrap');
            const mcWrap = qs('#mcWrap');
            const answerModeSelect = qs('#answerMode');
            const qTypeSelect = qs('#qType');
            const sylPerItemControl = qs('#sylPerItemControl');
            const btnReplayAudio = qs('#btnReplayAudio'); // Audio button (now handled by .btn-audio-current)

            const mode = answerModeSelect?.value; // Use optional chaining
            const qType = qTypeSelect?.value; // Use optional chaining

            // Sembunyikan semua secara default
            if (typeWrap) {
                typeWrap.hidden = true;
                typeWrap.style.display = 'none';
            }
            if (mcWrap) {
                mcWrap.hidden = true;
                mcWrap.style.display = 'none';
            }

            // Atur disabled state untuk #answerMode
            if (answerModeSelect) answerModeSelect.disabled = false;
            
            // Atur visibilitas #sylPerItemControl
            if (sylPerItemControl) {
                sylPerItemControl.hidden = !(qType === 'seq' || qType === 'kseq');
            }

            // Atur visibilitas dan disabled state untuk tombol audio di .btn-audio-current
            // Note: The audio button is now part of the .question flex container.
            // We just control its data-kana and visibility via bindAudioButtonToCurrent and its parent logic.
            const audioButton = qs('.btn-audio-current');
            if (audioButton) {
                // The visibility is handled by the question content itself now,
                // and bindAudioButtonToCurrent will ensure it plays the correct sound.
                // We ensure it's generally visible, and only hide it if explicitly not an audio type
                const isAudioQType = qType.startsWith('audio');
                audioButton.hidden = !isAudioQType;
                audioButton.disabled = !isAudioQType;
            }

            // Tampilkan wrapper yang sesuai
            if (qType === 'seq' || qType === 'kseq') {
                if (typeWrap) {
                    typeWrap.hidden = false;
                    typeWrap.style.display = 'block';
                }
                if (answerModeSelect) {
                    answerModeSelect.value = 'type';
                    answerModeSelect.disabled = true;
                }
            } else if (qType === 'r2k') {
                if (mcWrap) {
                    mcWrap.hidden = false;
                    mcWrap.style.display = 'grid';
                }
                if (answerModeSelect) {
                    answerModeSelect.value = 'mc';
                    answerModeSelect.disabled = true;
                }
            } else if (AUDIO_TYPES.has(qType) || qType === 'k2r') { // k2r, audio_k2r, audio_r2k
                if (mode === 'type') {
                    if (typeWrap) {
                        typeWrap.hidden = false;
                        typeWrap.style.display = 'block';
                    }
                } else { // mode === 'mc'
                    if (mcWrap) {
                        mcWrap.hidden = false;
                        mcWrap.style.display = 'grid';
                    }
                }
            }
        }


        function endTest(){
            qs('#testArea').style.opacity = '0';
            qs('#testArea').style.pointerEvents = 'none';
            qs('#testArea').addEventListener('transitionend', function handler() {
                qs('#testArea').hidden = true;
                qs('#testEmptyState').hidden = false;
                qs('#testArea').removeEventListener('transitionend', handler);
            }, { once: true });
            
            finishTest();
            updateProgress();
        }

        function nextQ(){
            if(state.test.total>=state.test.target){ finishTest(); return; }
            if(!testPool.length){ 
                qs('#qKana').textContent='Selesai!'; 
                // Tampilkan empty state jika testPool kosong
                if (qs('#testArea')) qs('#testArea').hidden = true;
                if (qs('#testEmptyState')) qs('#testEmptyState').hidden = false;
                return; 
            } 
            
            // Perbaikan spread object di currentItem
            const newCurrentItem = testPool[qIndex % testPool.length];
            const qType = state.test.qType;

            // Sumber pool untuk makeSequence/makeKanaSequence sekarang langsung dari `getChosenSubset()`
            // agar konsisten dengan `startTest()`.
            const sequencePoolLabels = getChosenSubset();


            if (qType === 'seq') {
                const seqData = makeSequence(sequencePoolLabels, state.test.set, state.test.sylPerItem);
                currentItem = { ...(newCurrentItem || {}), romaji: seqData.romaji, char: seqData.kana, qType: qType }; // PATCH: Spread object
            } else if (qType === 'kseq') {
                const seqData = makeKanaSequence(sequencePoolLabels, state.test.set, state.test.sylPerItem);
                currentItem = { ...(newCurrentItem || {}), kanaSeq: seqData.kana, romajiSeq: seqData.romaji, qType: qType }; // PATCH: Spread object
            } else {
                currentItem = { ...(newCurrentItem || {}), qType: qType }; // Untuk soal single char // PATCH: Spread object
            }

            const ansEl=qs('#ans'); 
            if(ansEl) ansEl.value='';
            
            const qKanaElement = qs('#qKana');
            if (qKanaElement) qKanaElement.classList.remove('correct-answer', 'wrong-answer');


            if (qType.startsWith('audio')) {
                if (qKanaElement) {
                    qKanaElement.textContent='Dengar & jawab';
                    qKanaElement.style.fontSize='24px';
                }
            } else if(qType==='seq'){
                if (qKanaElement) {
                    qKanaElement.textContent=`Romaji: ${escapeHTML(currentItem.romaji)}`;
                    qKanaElement.style.fontSize='28px';
                }
            }
            else if(qType==='kseq'){
                if (qKanaElement) {
                    qKanaElement.textContent = escapeHTML(currentItem.kanaSeq);
                    qKanaElement.style.fontSize = '48px';
                }
            }
            else if(qType==='k2r'){
                if (qKanaElement) {
                    qKanaElement.textContent=escapeHTML(currentItem.char);
                    qKanaElement.style.fontSize='64px';
                }
            }
            else { // r2k
                if (qKanaElement) {
                    qKanaElement.textContent=escapeHTML(currentItem.romaji);
                    qKanaElement.style.fontSize='36px';
                }
            }

            if(qs('#answerMode')?.value === 'mc') { // Use optional chaining
                const mcWrap = qs('#mcWrap');
                if (mcWrap) {
                    mcWrap.hidden = false;
                    mcWrap.style.display = 'grid'; // Pastikan display benar untuk grid
                }
                const typeWrap = qs('#typeWrap');
                if (typeWrap) {
                    typeWrap.hidden = true;
                    typeWrap.style.display = 'none';
                }

                if(qType==='k2r' || qType === 'audio_k2r') {
                    buildMC_k2r(currentItem);
                } else if (qType === 'r2k' || qType === 'audio_r2k') {
                    buildMC_r2k(currentItem);
                }
            } else {
                const mcWrap = qs('#mcWrap');
                if (mcWrap) {
                    mcWrap.hidden = true;
                    mcWrap.style.display = 'none';
                }
                const typeWrap = qs('#typeWrap');
                if (typeWrap) {
                    typeWrap.hidden = false;
                    typeWrap.style.display = 'block';
                }
            }

            updateTestInfo();
            toggleAnswerUI();
            setTimeout(()=>{
                const tw = qs('#typeWrap');
                const mcw = qs('#mcWrap');
                if (tw && getComputedStyle(tw).display !== 'none') ansEl && ansEl.focus();
                else if (mcw && getComputedStyle(mcw).display !== 'none') qs('#optA')?.focus();
            }, 30);

            // Panggil afterRenderQuestion() di akhir fungsi render soalmu.
            afterRenderQuestion();
        }

        // Panggil afterRenderQuestion() di akhir fungsi render soalmu.
        window.afterRenderQuestion = function(){
            const qType = (qs('#qType')?.value || window.state?.test?.qType || '').toLowerCase();
            const btnAudioCurrent = qs('.btn-audio-current'); // Menggunakan class
            
            if (btnAudioCurrent){
                const isAudioType = qType.includes('audio');
                btnAudioCurrent.hidden = !isAudioType;
                btnAudioCurrent.disabled = !isAudioType;
            }
            // Setelah currentItem terpasang, panggil bindAudioButtonToCurrent();
            bindAudioButtonToCurrent();
            // Panggil enforceInputDiscipline
            enforceInputDiscipline();
            // TIDAK ada pemanggilan ttsSpeak/playAudio di sini.
        };


        function chooseMC(idx){
            const cq = window.state?.test?.current || window.currentQuestion || currentItem;
            if (!cq) return;
            
            const qType = state.test.qType;
            let correct = false;
            let pickedValue = null;

            const optionKey = ['A', 'B', 'C', 'D'][idx];
            if (optionKey && mcMap[optionKey]) {
                pickedValue = mcMap[optionKey];
            } else {
                return; // Invalid index or option
            }

            if (qType === 'k2r' || qType === 'audio_k2r') {
                correct = (pickedValue === cq.romaji);
            } else if (qType === 'r2k' || qType === 'audio_r2k') {
                const targetKana = (state.test.set === 'hira' ? HIRA_MAP.get(cq.romaji) : KATA_MAP.get(cq.romaji));
                correct = (pickedValue === targetKana);
            }
            
            // Berikan visual feedback ke tombol yang dipilih
            qsa('#mcWrap .btn.opt').forEach((btn, i) => {
                if (i === idx) {
                    btn.classList.add(correct ? 'ok' : 'warn'); // Add temporary class
                }
            });

            finalizeAnswer(correct, { chosen: pickedValue });

            // Hapus kelas feedback setelah penundaan
            setTimeout(() => {
                qsa('#mcWrap .btn.opt').forEach(btn => {
                    btn.classList.remove('ok', 'warn');
                });
            }, 300); // Sesuaikan dengan durasi animasi CSS jika ada
        }


        function normalizeRomajiSequence(s){
            return (s||'').toLowerCase().replace(/\s+/g,''); 
        }

        function romajiEquals(a,b){
            if (!a || !b) return false;
            if (a === b) return true; // Cepat keluar jika sama persis
            const canon = (t)=> {
                let text = t.toLowerCase();
                text = text.replace(/wo/g,'o');
                text = text.replace(/ji|di/g,'dji');
                text = text.replace(/zu|du/g,'dzu');
                return text;
            };
            return canon(a) === canon(b);
        }

        function checkAns(){
            const valRaw=(qs('#ans')?.value||'').trim();
            const qType=state.test.qType;
            let correct=false;
            let normalizedInput='';
            let userKanaForReview = '';

            if(qType==='k2r' || qType==='audio_k2r'){
                const norm = normalizeRomaji(valRaw);
                normalizedInput = norm;
                correct = romajiEquals(norm, currentItem.romaji);
                // Hanya konversi ke kana jika itu audio_k2r, untuk tujuan review feedback
                if (qType === 'audio_k2r') userKanaForReview = romajiStringToKana(norm, state.test.set);
            }
            else if(qType==='seq'){
                const expectedKana = currentItem.char; // Kana dari seqData.kana
                const rawSeq = normalizeRomajiSequence(valRaw);
                userKanaForReview = romajiStringToKana(rawSeq, state.test.set);
                correct = (userKanaForReview === expectedKana);
                normalizedInput = userKanaForReview;
            }
            else if(qType==='audio_r2k'){ // Romaji -> Kana, user ketik Romaji, kita konversi ke Kana
                const expectedKana = (state.test.set==='hira'? HIRA_MAP.get(currentItem.romaji): KATA_MAP.get(currentItem.romaji));
                const romajiToConvert = normalizeRomaji(valRaw);
                userKanaForReview = romajiStringToKana(romajiToConvert, state.test.set);
                correct = (userKanaForReview === expectedKana);
                normalizedInput = romajiToConvert; // Normalized romaji input
            }
            else if(qType==='kseq'){
                const expectedRomajiSeq = currentItem.romajiSeq;
                const userRomajiSeq = normalizeRomajiSequence(valRaw);
                normalizedInput = userRomajiSeq;
                correct = (userRomajiSeq === expectedRomajiSeq);
            }
            finalizeAnswer(correct, {typed:valRaw, normalized: normalizedInput, userKana: userKanaForReview});
        }

        function finalizeAnswer(correct, extra){
            const qKanaElement = qs('#qKana');
            const streakCounterElement = qs('#streakCounter');
            const currentKanaChar = currentItem.char || (currentItem.kanaSeq ? currentItem.kanaSeq : '');
            const currentRomaji = currentItem.romaji || (currentItem.romajiSeq ? currentItem.romajiSeq : '');
            const userInput = extra.typed || extra.chosen || extra.normalized || '-';

            state.test.total+=1;
            if(correct){
                state.test.score+=1;
                state.test.correctStreak+=1;
                state.totalPoints += 1;
                checkLevelUp();
                maybeCelebrate('streak');
                clickTone('ok');
                if (qKanaElement) qKanaElement.classList.add('correct-answer');
                if (streakCounterElement) streakCounterElement.classList.add('grow');
                let okMsg = t('feedback_correct', escapeHTML(currentKanaChar), escapeHTML(currentRomaji));
                const ui = (extra.typed || extra.normalized || '').toLowerCase();
                if ((currentRomaji === 'dji' && ['ji','di'].includes(ui)) || (currentRomaji === 'dzu' && ['zu','du'].includes(ui))) {
                    okMsg += ` (jawabanmu "${escapeHTML(ui)}" diterima)`; // Changed to Indonesian
                }
                showToast(okMsg);
                const romajiKey = currentItem.romaji || currentItem.romajiSeq;
                if (romajiKey) {
                    const currentBox = state.srs.boxes[romajiKey] || 1;
                    const nextBox = Math.min(5, currentBox + 1);
                    state.srs.boxes[romajiKey] = nextBox;
                    state.srs.due[romajiKey] = Math.floor(Date.now() / 1000) + SRS_INTERVAL[nextBox];
                }

            } else {
                state.test.correctStreak=0;
                // Rapikan push ke wrong list (kalau sebelumnya ada {.currentItem, .extra})
                wrongList.push({ ...currentItem, ...extra }); // Corrected spread
                clickTone('bad');
                if (qKanaElement) qKanaElement.classList.add('wrong-answer');
                let feedbackMsg = t('feedback_wrong', escapeHTML(currentKanaChar), escapeHTML(currentRomaji), escapeHTML(userInput));
                if ((currentRomaji === 'dji' || currentRomaji === 'dzu') && (userInput === 'ji' || userInput === 'zu' || userInput === 'di' || userInput === 'du')) {
                    feedbackMsg = t('feedback_wrong_dji_dzu', escapeHTML(currentKanaChar), escapeHTML(currentRomaji), escapeHTML(userInput));
                }
                showToast(feedbackMsg, 'warn');

                const currentSet = state.test.set;
                let wrongKanaChar = '';
                let correctKanaCharToLog = currentKanaChar;

                if (state.test.qType === 'r2k' || state.test.qType === 'audio_r2k') {
                    wrongKanaChar = extra.chosen;
                } else if (state.test.qType === 'k2r' || state.test.qType === 'audio_k2r') {
                    const userRomajiNormalized = normalizeRomaji(extra.typed || extra.chosen);
                    wrongKanaChar = romajiStringToKana(userRomajiNormalized, currentSet);
                } else if (state.test.qType === 'seq') {
                    wrongKanaChar = extra.userKana;
                    correctKanaCharToLog = currentItem.char;
                    if (wrongKanaChar.length === 1 && correctKanaCharToLog.length === 1 && wrongKanaChar !== correctKanaCharToLog) {
                        const pair = _pairKey(correctKanaCharToLog, wrongKanaChar);
                        state.confusionLog[currentSet][pair] = (state.confusionLog[currentSet][pair] || 0) + 1;
                    } else {
                        wrongKanaChar = null;
                    }
                } else if (state.test.qType === 'kseq') {
                    // Untuk kseq, romajiSeq adalah target, jadi userKana tidak relevan untuk confusion log
                    wrongKanaChar = null; 
                }

                if (wrongKanaChar && correctKanaCharToLog && wrongKanaChar !== correctKanaCharToLog) {
                    const pair = _pairKey(correctKanaCharToLog, wrongKanaChar);
                    state.confusionLog[currentSet][pair] = (state.confusionLog[currentSet][pair] || 0) + 1;
                }

                const romajiKey = currentItem.romaji || currentItem.romajiSeq;
                if (romajiKey) {
                    state.srs.boxes[romajiKey] = 1;
                    state.srs.due[romajiKey] = Math.floor(Date.now() / 1000);
                }
            }

            setTimeout(() => {
                if (qKanaElement) qKanaElement.classList.remove('correct-answer', 'wrong-answer');
                if (streakCounterElement) streakCounterElement.classList.remove('grow');
            }, 300);

            updateProgress();
            if(state.test.total>=state.test.target){ finishTest(); return; }
            qIndex=(qIndex+1)%testPool.length; 
            save();
            renderStats();
            nextQ(); 
        }

        // Perbaikan utilitas shuffle:
        function shuffleReturn(arr){ const a=[...arr]; shuffle(a); return a; }

        // Ganti total buildMC_k2r(item) (Kana→Romaji = opsi ROMAJI saja):
        function buildMC_k2r(item){
            const set = state?.test?.set || 'hira'; // 'hira' | 'kata'
            const map = set==='hira' ? HIRA_MAP : KATA_MAP;

            const targetRomaji = item.romaji;
            const targetKana   = map.get(targetRomaji);
            const ALL_R = Array.from(map.keys()); // semua romaji dalam set

            // Helper: dari kana -> romaji (pakai map inverse)
            const kanaToRomaji = (kana)=>{
                for (const r of ALL_R){ if (map.get(r)===kana) return r; }
                // Handle dji/dzu jika mereka tidak langsung di map (jika menggunakan alias)
                if (set === 'hira') {
                    if (kana === 'ぢ') return 'dji';
                    if (kana === 'づ') return 'dzu';
                } else { // kata
                    if (kana === 'ヂ') return 'dji';
                    if (kana === 'ヅ') return 'dzu';
                }
                return null;
            };

            let decoys = [];

            // 1) Confusion pairs -> ubah ke romaji
            const confusedKana = Object.entries(state.confusionLog?.[set]||{})
                .filter(([pair])=> pair.includes(targetKana))
                .sort(([,a],[,b])=> b-a)
                .map(([pair])=> { const [k1,k2]=pair.split('|'); return k1===targetKana ? k2 : k1; })
                .filter(k => k && k!==targetKana);

            const confusedRomaji = confusedKana.map(kanaToRomaji).filter(r => r && r!==targetRomaji);
            decoys.push(...shuffleReturn(confusedRomaji).slice(0,2));

            // 2) Tambah romaji dengan panjang sama
            const available = ALL_R.filter(r => r!==targetRomaji && !decoys.includes(r));
            const sameLen   = available.filter(r => r.length===targetRomaji.length);
            decoys.push(...shuffleReturn(sameLen).slice(0, Math.max(0, 3 - decoys.length))); // Tambah Math.max(0, ...)

            // 3) Fallback
            if (decoys.length < 3) decoys.push(...shuffleReturn(available).slice(0, Math.max(0, 3 - decoys.length))); // Tambah Math.max(0, ...)

            // Final 4 opsi romaji unik
            const options = [targetRomaji, ...decoys].slice(0,4);
            const uniq = Array.from(new Set(options));
            while (uniq.length < 4){
                const fb = ALL_R.find(r => !uniq.includes(r) && r!==targetRomaji);
                if (!fb) break; uniq.push(fb);
            }
            shuffle(uniq);

            mcMap = {A:uniq[0], B:uniq[1], C:uniq[2], D:uniq[3]};
            setMCText({A:`A. ${escapeHTML(uniq[0])}`, B:`B. ${escapeHTML(uniq[1])}`, C:`C. ${escapeHTML(uniq[2])}`, D:`D. ${escapeHTML(uniq[3])}`});
        }
        
        // Ganti total buildMC_r2k(item) (Romaji→Kana = opsi KANA saja):
        function buildMC_r2k(item){
            const set = state?.test?.set || 'hira';
            const map = set==='hira' ? HIRA_MAP : KATA_MAP;

            const correctRomaji = item.romaji;
            const correctKana   = map.get(correctRomaji);
            if (!correctKana){
                console.warn('Cannot map romaji -> kana', correctRomaji, set);
                mcMap = {A:'-',B:'-',C:'-',D:'-'};
                setMCText({A:'A. -',B:'B. -',C:'C. -',D:'D. -'}); 
                return;
            }

            // Semua kana dari pool (gunakan semua kana yang ada di map untuk opsi)
            const ALL_R = Array.from(map.keys());
            const allKanaInPool = ALL_R.map(r => map.get(r)).filter(Boolean);

            let decoys = [];

            // 1) Confusion pairs langsung KANA
            const confusedKana = Object.entries(state.confusionLog?.[set]||{})
                .filter(([pair])=> pair.includes(correctKana))
                .sort(([,a],[,b])=> b-a)
                .map(([pair])=> { const [k1,k2]=pair.split('|'); return k1===correctKana ? k2 : k1; })
                .filter(k => k && k!==correctKana);

            decoys.push(...shuffleReturn(confusedKana).slice(0,2));

            // 2) Similar shape (opsional, jika helper tersedia)
            if (typeof similarChoicesHira==='function' || typeof similarChoicesKata==='function'){
                const similarFn = set==='hira' ? similarChoicesHira : similarChoicesKata;
                const similar = (similarFn?.(correctKana)||[]).filter(k=>k && !decoys.includes(k) && allKanaInPool.includes(k)); // Pastikan unik dan ada di pool
                decoys.push(...shuffleReturn(similar).slice(0, Math.max(0, 3 - decoys.length)));
            }

            // 3) Fallback kana random (dari pool yang tersedia)
            if (decoys.length < 3){
                const rest = allKanaInPool.filter(k => k!==correctKana && !decoys.includes(k));
                decoys.push(...shuffleReturn(rest).slice(0, Math.max(0, 3 - decoys.length)));
            }

            // Final 4 opsi KANA unik
            const options = [correctKana, ...decoys].slice(0,4);
            const uniq = Array.from(new Set(options));
            while (uniq.length < 4){
                const fb = allKanaInPool.find(k => k && !uniq.includes(k) && k!==correctKana);
                if (!fb) break; uniq.push(fb);
            }
            shuffle(uniq);

            mcMap = {A:uniq[0], B:uniq[1], C:uniq[2], D:uniq[3]};
            setMCText({A:`A. ${escapeHTML(uniq[0])}`, B:`B. ${escapeHTML(uniq[1])}`, C:`C. ${escapeHTML(uniq[2])}`, D:`D. ${escapeHTML(uniq[3])}`});
        }


        function setMCText(map){ ['A','B','C','D'].forEach(k=>{ const el=qs('#opt'+k); if(el) el.textContent=map[k]; }); }

        function skipQ(){
            clickTone('click');
            showToast(t('feedback_skipped'));
            if(!testPool.length){ return; }
            qIndex=(qIndex+1)%testPool.length;
            nextQ();
        }

        /**
         * Mengembalikan label rentang yang sedang aktif untuk ditampilkan di UI.
         * Menyesuaikan dengan mode rentang (range/single) atau chip khusus.
         * @returns {string} Label rentang.
         */
        function currentRangeLabel(){
            // Check if any specific subset chip is active
            if (state.test.subset === 'all') {
                return t('all_kana_label');
            } else if (state.test.subset === 'confusion') {
                return t('confuse_train_label');
            } else if (state.test.subset === 'srs_due') {
                return t('review_today_label');
            } else if (state.test.subset === 'jft-drill') {
                return t('jft_drill_label');
            } else {
                // Check if a group chip is active (e.g., 'k', 's', 'm')
                const activeGroupChip = GROUPS.find(g => g.key === state.test.subset);
                if (activeGroupChip) {
                    return activeGroupChip.label;
                }
            }
            
            // Fallback to range/single mode if no specific chip is active
            if(elRangeMode?.value === 'range'){ // Use optional chaining
                if (!elFrom || !elTo || elFrom.selectedIndex < 0 || elTo.selectedIndex < 0) return 'Rentang tidak valid';
                return `${elFrom.options[elFrom.selectedIndex].text} → ${elTo.options[elTo.selectedIndex].text}`;
            }
            if(elRangeMode?.value === 'single'){ // Use optional chaining
                if (!elSingle || elSingle.selectedIndex < 0) return 'Grup tidak valid';
                return `${elSingle.options[elSingle.selectedIndex].text}`;
            }
            return 'Semua'; // Default if none selected
        }

        function updateTestInfo(){
            const rangeLabel = currentRangeLabel();

            const tlabel = {
                'k2r': t('test_type_k2r'), 
                'r2k': t('test_type_r2k'), 
                'seq': t('test_type_seq'),
                'audio_k2r': t('test_type_audio_k2r'),
                'audio_r2k': t('test_type_audio_r2k'),
                'kseq': t('test_type_kseq')
            }[state.test.qType] || 'Tes';

            const testInfoTextElement = qs('#testInfoText');
            const streakCounterElement = qs('#streakCounter');

            if (testInfoTextElement) {
                testInfoTextElement.textContent = t('test_info_text', state.test.set==='hira'?'Hiragana':'Katakana', rangeLabel, tlabel, state.test.total, state.test.target);
            }
            if (streakCounterElement) streakCounterElement.textContent = t('test_streak', state.test.correctStreak);
        }

        function updateProgress(value){
            const pct = (state.test.total/state.test.target)*100;
            const bar = qs('#bar');
            if (bar) bar.style.width = pct+'%';
            const prog = qs('.progress');
            if (prog) prog.setAttribute('aria-valuenow', Math.round(pct));
        }

        function finishTest(){
            openCelebrate('finish');
            if (!state.lite && !window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                burst();
            }
            clickTone('ok');
            renderReview();
            updatePointsAndLevelDisplay();
            renderStats();
            // Setelah tes selesai, tawarkan "Latih yang Membingungkan"
            // Mengganti confirm() dengan showCustomConfirm()
            showCustomConfirm('Tes selesai! Apakah kamu ingin melatih pasangan yang membingungkan?', (confirmed) => {
                if (confirmed) {
                    state.test.subset = 'confusion';
                    state.test.target = 20; // Default 20 soal untuk latihan ulang
                    state.test.qType = 'k2r'; // Default k2r untuk confusion
                    state.test.mode = 'mc'; // Default MC
                    save();
                    // Update UI controls
                    qs('#testCount').value = state.test.target;
                    qs('#qType').value = state.test.qType;
                    qs('#answerMode').value = state.test.mode;
                    buildSubsetChips(); // Rebuild chips to set 'confusion' as active
                    updateRangeUI(); // Update range UI (will hide range controls)
                    updateTestInfo(); // Update info text
                    startTest();
                }
            });
        }

        function renderReview(){
            const box=qs('#reviewWrap');
            const hasWrong = wrongList.length>0;
            if (qs('#btnReviewWrong')) qs('#btnReviewWrong').hidden=!hasWrong;
            if (box) box.hidden=!hasWrong;
            if (qs('#celebrateMsg')) qs('#celebrateMsg').textContent=t('done_test_sub', state.test.score, state.test.total);
            if(!hasWrong){
                if (box) box.innerHTML=`<div class="small" style="grid-column: span 4; text-align: center;">${t('empty_review')}</div>`;
                return;
            }
            const set=state.test.set;
            if (box) {
                box.innerHTML = wrongList.map((w,i)=>{
                    const expectedKanaChar = w.char;
                    const expectedRomaji = w.romaji;
                    const givenInput = w.typed || w.chosen || w.normalized || '-';
                    let displayedKana = '';
                    let displayedExpectedAnswer = '';
                    let displayedGivenAnswer = '';

                    if (w.qType === 'k2r' || w.qType === 'audio_k2r') {
                        displayedKana = expectedKanaChar;
                    } else if (w.qType === 'r2k' || w.qType === 'audio_r2k') {
                        displayedKana = expectedRomaji;
                    } else if (w.qType === 'seq') {
                        displayedKana = `Romaji: ${expectedRomaji}`;
                    } else if (w.qType === 'kseq') {
                        displayedKana = expectedKanaChar;
                    }

                    if (w.qType === 'k2r' || w.qType === 'audio_k2r' || w.qType === 'kseq') {
                        displayedExpectedAnswer = expectedRomaji;
                    } else {
                        displayedExpectedAnswer = expectedKanaChar;
                    }

                    if (w.qType === 'r2k' || w.qType === 'audio_r2k' || w.qType === 'seq') {
                        displayedGivenAnswer = givenInput;
                        if (w.userKana && w.userKana !== givenInput) {
                            displayedGivenAnswer += ` (${w.userKana})`;
                        }
                    } else {
                        displayedGivenAnswer = givenInput;
                    }

                    let specialNote = '';
                    if ((expectedRomaji === 'dji' && (givenInput.toLowerCase() === 'ji' || givenInput.toLowerCase() === 'di')) ||
                        (expectedRomaji === 'dzu' && (givenInput.toLowerCase() === 'zu' || givenInput.toLowerCase() === 'du'))) {
                        specialNote = `<span class="small" style="color:var(--muted)"> (diterima sebagai ${escapeHTML(expectedRomaji)})</span>`; // Changed to Indonesian
                    }


                    return `<div style="padding:8px;border:1px solid var(--border);border-radius:12px;margin:6px 0;display:flex;justify-content:space-between;align-items:center;gap:8px">
                                <div>
                                    <div class="small">Soal ${i+1}</div>
                                    <div><b>${escapeHTML(displayedKana)}</b> → <span style="color:var(--ok)">${escapeHTML(displayedExpectedAnswer)}</span></div>
                                    <div class="small">Jawaban kamu: ${escapeHTML(displayedGivenAnswer)}${specialNote}</div>
                                </div>
                                <button class="btn" onclick="window._speak('${escapeHTML(expectedKanaChar || expectedRomaji)}')" type="button" aria-label="Play pronunciation ${escapeHTML(expectedKanaChar || expectedRomaji)}">🎧</button>
                            </div>`;
                }).join('');
            }
        }

        bind('#btnReviewWrong', 'click', ()=>{ if(!wrongList.length) return; const set=state.test.set; 
            testPool = wrongList.map(w => {
                return { 
                    romaji: w.romaji, 
                    char: w.char, 
                    kanaSeq: w.kanaSeq, 
                    romajiSeq: w.romajiSeq, 
                    qType: w.qType,
                    subset: state.test.subset
                };
            });
            shuffle(testPool);

            poolIdx = buildPoolLabels().map(r=>ALL_ROMAJI.indexOf(r)).filter(x=>x>=0);
            state.test.total=0; state.test.score=0; state.test.correctStreak=0; state.test.target = Math.min(20, testPool.length); qIndex=0; 
            closeCelebrate(); 
            if (qs('#testArea')) qs('#testArea').hidden=false; 
            if (qs('#testArea')) qs('#testArea').style.opacity = '0';
            if (qs('#testArea')) qs('#testArea').style.pointerEvents = 'none';
            setTimeout(() => {
                if (qs('#testArea')) qs('#testArea').style.opacity = '1';
                if (qs('#testArea')) qs('#testArea').style.pointerEvents = 'auto';
            }, 10);
            updateProgress(); 
            nextQ(); 
        });

        /**
         * Mengembalikan array romaji untuk fitur tertentu (review/confusion/seq).
         * Disinkronkan dengan logika baru: ketika subset bukan chip khusus,
         * gunakan state.test.rangeMode & rentang/single seperti di A.1.
         * JANGAN dipakai untuk penentuan awal labels soal reguler (pakai getChosenSubset()).
         * @returns {string[]} Array of romaji labels.
         */
        function buildPoolLabels(){
            // Jika ada chip subset khusus yang aktif, gunakan itu.
            if (state.test.subset === 'all') {
                return ALL_ROMAJI;
            } else if (state.test.subset === 'confusion') {
                return _confuseTopPairs(state.test.set);
            } else if (state.test.subset === 'srs_due') {
                return getDueReviewItems(state.test.set).map(item => item.romaji);
            } else if (state.test.subset === 'jft-drill') {
                const jftGroups = GROUPS.filter(g => 
                    (g.key >= 'aiueo' && g.key <= 'r') ||
                    (g.key === 'g' || g.key === 'z' || g.key === 'd')
                );
                return jftGroups.flatMap(g => romajiFromGroup(g));
            } else {
                // Jika tidak ada chip khusus aktif, gunakan mode rentang/single yang aktif.
                if (state.test.rangeMode === 'range') {
                    const labels = rangeLabels(state.test.rangeFrom, state.test.rangeTo);
                    return labels.length > 0 ? labels : ALL_ROMAJI; // Fallback jika kosong
                } else if (state.test.rangeMode === 'single') {
                    const singleGroup = GROUPS.find(g => g.key === state.test.singleGroup);
                    if (singleGroup) {
                        const labels = romajiFromGroup(singleGroup);
                        return labels.length > 0 ? labels : ALL_ROMAJI; // Fallback jika kosong
                    }
                    return ALL_ROMAJI; // Fallback jika grup tunggal tidak ditemukan
                }
            }
            // Fallback default jika tidak ada kondisi yang cocok
            return ALL_ROMAJI; 
        }

        function rangeLabels(fromKey,toKey){ const a=GROUPS.findIndex(g=>g.key===fromKey); const b=GROUPS.findIndex(g=>g.key===toKey); if(a<0||b<0) return []; const [from,to] = a<=b? [a,b]:[b,a]; return GROUPS.slice(from,to+1).flatMap(g=> g.idx.map(i=> g.list[i]) ); }
        // function currentPoolLabels(){ return testPool.map(x=>x.romaji); } // No longer directly used
        // function currentPoolChars(){ return testPool.map(x=>x.char); } // No longer directly used

        // This function is now mostly redundant as updateRangeUI handles visibility.
        // Keeping it for now but might remove if it causes conflicts.
        function toggleRangeInputs() {
            // This function is now largely handled by updateRangeUI, but keep it for consistency if other parts call it.
            // Ensure elements are initialized before trying to access their values
            if (!elRangeMode || !elFrom || !elTo || !elSingle || !elToWrap) return;

            const rangeMode = elRangeMode.value;
            
            // Determine if a specific subset chip is active (excluding 'all', 'confusion', 'srs_due')
            const isSpecialSubsetActive = (state.test.subset !== 'all' && state.test.subset !== 'confusion' && state.test.subset !== 'srs_due' && state.test.subset !== 'jft-drill' && !GROUPS.some(g => g.key === state.test.subset));

            // If a specific subset chip is selected, the rangeMode should reflect that.
            if (isSpecialSubsetActive) {
                // When a specific chip (like a group chip or confusion/srs_due) is active,
                // we should hide the range/single group selector and show the corresponding
                // elements as if rangeMode was set internally.
                if (elRangeMode) { elRangeMode.setAttribute('inert', ''); elRangeMode.hidden = true; }
                setEnabled(elFrom, false);
                setEnabled(elTo, false);
                if (elToWrap) elToWrap.hidden = true;
                setEnabled(elSingle, false); // No single group for specific chips as the chip itself defines the selection
            } else {
                if (elRangeMode) { elRangeMode.removeAttribute('inert'); elRangeMode.hidden = false; }
                updateRangeUI(); // Apply range mode logic based on elRangeMode.value
            }
            updateTestInfo(); // Update test info text after range inputs are toggled
        }


        // New: Quick Presets
        const QUICK_PRESETS = {
            'aiueo-m': ['aiueo', 'm'], // a i u e o → ma mi mu me mo
            'base-all': ['aiueo','w'],
            'dakuon-all': ['g','p'],
            'youon-all': ['ky','py'],
            // Preset JFT Drill is handled as a special subset in getChosenSubset()
            // so we don't need to define its range here for applyPreset directly.
            // The JFT Drill chip will set state.test.subset = 'jft-drill'
            // and getChosenSubset will handle the logic.
        };

        function applyPreset(key){
            const preset = QUICK_PRESETS[key];
            if (!preset) return;

            // If it's a JFT Drill preset, set the subset and let getChosenSubset handle it.
            // Note: The JFT Drill chip now directly sets state.test.subset = 'jft-drill'
            // so this `if (key === 'jft-drill')` block in applyPreset is no longer strictly needed
            // if the chip itself handles the state.test.subset change.
            // However, if presets could be triggered by other means, this logic would be valid.
            if (key === 'jft-drill') {
                state.test.subset = 'jft-drill';
                state.test.set = 'hira'; // Default for JFT Drill
                state.test.qType = 'k2r'; // Default for JFT Drill
                state.test.mode = 'mc'; // Default for JFT Drill
                state.test.target = 20; // Default for JFT Drill
                // The range inputs will be hidden by updateRangeUI due to the 'jft-drill' subset.
            } else {
                // For other range presets
                state.test.rangeMode = 'range'; // Ensure it's in range mode
                if (qs('#rangeMode')) qs('#rangeMode').value = 'range';
                updateRangeUI(); // This will show #testFrom and #testTo
                if (qs('#testFrom')) qs('#testFrom').value = preset[0];
                if (qs('#testTo')) qs('#testTo').value = preset[1];
                ensureValidRange(); // Ensures from/to are valid and saves them
                
                // Clear subset if a range preset is selected, so range controls are visible
                state.test.subset = ''; 
            }
            save(); // Save state after applying preset
            buildSubsetChips(); // Rebuild to clear active state on 'all', 'confusion', 'srs_due' or set current preset chip active
            updateRangeUI(); // Re-apply UI state based on new subset/rangeMode
            updateTestInfo(); // Update test info text
            clickTone('click');
        }
        
        // ---------- THEME & AUDIO ----------
        function applyTheme(){
            document.documentElement.setAttribute('data-theme', state.theme==='hc'?'hc':'pastel');
            const isHC = state.theme==='hc';
            const bPastel = qs('#tPastel'), bHC = qs('#tHC');
            if (bPastel) {
                bPastel.classList.toggle('active', !isHC);
                bPastel.setAttribute('aria-selected', String(!isHC));
            }
            if (bHC) {
                bHC.classList.toggle('active', isHC);
                bHC.setAttribute('aria-selected', String(isHC));
            }
            const metaTheme = document.querySelector('meta[name="theme-color"]');
            if (metaTheme) {
              const bg = getComputedStyle(document.documentElement).getPropertyValue('--panel').trim() || (isHC ? '#0f1626' : '#ffffff');
              metaTheme.setAttribute('content', bg);
            }
        }
        function applyAudio(){ const ck=qs('#audToggle'); if (ck) ck.checked = !!state.audio; }

        // Reused AudioContext for performance
        let _audioCtx = null;
        function clickTone(kind){
            try{
                if(!state.audio) return;
                const C = window.AudioContext || window.webkitAudioContext;
                if(!C) return;
                _audioCtx = _audioCtx || new C();
                const ctx = _audioCtx;

                if (ctx.state !== 'running') { ctx.resume().catch(()=>{}); }

                const o=ctx.createOscillator();
                const g=ctx.createGain();
                o.connect(g);
                g.connect(ctx.destination);
                o.type='sine';
                o.frequency.setValueAtTime(kind==='ok'? 960: kind==='bad'? 260: 520, ctx.currentTime);
                g.gain.setValueAtTime(0.0001, ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(kind==='bad'?0.25:0.12, ctx.currentTime+0.01);
                o.start();
                setTimeout(()=>{
                    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.2);
                    o.stop(ctx.currentTime+0.22);
                }, 150);
            }catch(e){ console.error('Error playing sound:', e); }
        }

        let currentToast = null;
        let toastTimeout = null;
        function showToast(message, type = 'info', duration = 2500) {
            if (currentToast) {
                currentToast.remove();
                clearTimeout(toastTimeout);
            }

            const toast = document.createElement('div');
            toast.className = 'toast';
            if (type === 'warn') toast.classList.add('warn');
            
            toast.textContent = message;
            toast.setAttribute('role', 'status');
            toast.setAttribute('aria-live', 'polite');

            document.body.appendChild(toast);
            currentToast = toast;
            window.currentToast = toast; 

            setTimeout(() => {
                if (currentToast === toast) {
                    toast.style.opacity = '1';
                }
            }, 10);

            toastTimeout = setTimeout(() => {
                if (currentToast === toast) {
                    toast.style.opacity = '0';
                }
            }, duration);

            toast.addEventListener('transitionend', function handler() {
                if (toast.style.opacity === '0') {
                    toast.remove();
                    if (currentToast === toast) {
                        currentToast = null;
                        window.currentToast = null;
                    }
                    toast.removeEventListener('transitionend', handler);
                }
            });
        }


        // ---------- CELEBRATION ----------
        const modal = qs('#celebrate'); const burstBox = qs('#burst');
        let _escCloseListener = null;
        let _modalKeydownListener = null;

        function maybeCelebrate(type, level = 0){
            const isReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

            if(type==='streak' && state.test.correctStreak>0 && state.test.correctStreak % 10 === 0){
                openCelebrate('streak');
                if (!isReducedMotion && !state.lite) burst();
                clickTone('ok');
            } else if (type === 'levelUp') {
                if (qs('#celebrateTitle')) qs('#celebrateTitle').textContent = t('level_up_title', level); 
                if (qs('#celebrateMsg')) qs('#celebrateMsg').textContent = t('level_up_msg', LEVEL_NAMES[level-1] || `Level ${level}`);
                openCelebrate('levelUp');
                if (!isReducedMotion && !state.lite) burst();
                clickTone('ok');
            }
        }
        function openCelebrate(mode){
            const title=qs('#celebrateTitle'), msg=qs('#celebrateMsg');
            if(mode==='finish'){
                if (title) title.textContent=t('done_test_title');
                if (msg) msg.textContent=t('done_test_sub', state.test.score, state.test.total);
            } else if (mode === 'levelUp') {
                // Text already set in maybeCelebrate
            } else { // streak
                if (title) title.textContent=t('streak_title');
                if (msg) msg.textContent=t('streak_msg');
            }
            if (modal) {
                modal.hidden = false;
                modal.classList.add('is-open');
            }
            _trapModal();
        }

        function closeCelebrate(){
            if (modal) {
                modal.classList.remove('is-open');
                modal.addEventListener('transitionend', function handler() {
                    modal.hidden = true;
                    modal.removeEventListener('transitionend', handler);
                }, { once: true });
            }
            void document.body.offsetHeight;
            requestAnimationFrame(()=>{
                document.documentElement.style.transform='translateZ(0)';
                setTimeout(()=> document.documentElement.style.transform='', 0);
            });

            if (_escCloseListener) {
                document.removeEventListener('keydown', _escCloseListener);
                _escCloseListener = null;
            }
            if (_modalKeydownListener) {
                modal.removeEventListener('keydown', _modalKeydownListener);
                _modalKeydownListener = null;
            }
            const ansEl = qs('#ans');
            if (ansEl && !qs('#testArea')?.hidden && getComputedStyle(qs('#typeWrap') || {display:'none'}).display !== 'none') { // Added optional chaining and default display
                ansEl.focus();
            }
        }
        bind('#btnCloseModal', 'click', closeCelebrate);

        function _escClose(e){
            if(e.key==='Escape') {
                closeCelebrate();
            }
        }

        function _trapModal(){
            if (!modal) return;
            const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
            const focusables = modal.querySelectorAll(focusableElements);
            const firstFocusable = focusables[0];
            const lastFocusable = focusables[focusables.length - 1];

            if (!_escCloseListener) {
                _escCloseListener = _escClose;
                document.addEventListener('keydown', _escCloseListener);
            }
            
            if (!_modalKeydownListener) {
                _modalKeydownListener = (e) => {
                    const isTabPressed = (e.key === 'Tab' || e.keyCode === 9);

                    if (!isTabPressed) {
                        return;
                    }

                    if (e.shiftKey) {
                        if (document.activeElement === firstFocusable) {
                            lastFocusable.focus();
                            e.preventDefault();
                        }
                    } else {
                        if (document.activeElement === lastFocusable) {
                            firstFocusable.focus();
                            e.preventDefault();
                        }
                    }
                };
                modal.addEventListener('keydown', _modalKeydownListener);
            }

            firstFocusable?.focus();
        }

        function burst(){ 
            if (state.lite || window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                return;
            }
            if (!burstBox) return;
            burstBox.innerHTML=''; 
            const colors=['#7a6cff','#16c6a1','#ffd166','#ff7b7b','#2fb875','#8acbff']; 
            const w=window.innerWidth, h=window.innerHeight; 
            for(let i=0;i<90;i++){ 
                const p=document.createElement('div'); 
                p.className='particle'; 
                p.style.background=colors[i%colors.length]; 
                const dx=(Math.random()*w - w/2)+'px'; 
                const dy=(Math.random()*h/2)+'px'; 
                p.style.setProperty('--dx',dx); 
                p.style.setProperty('--dy',dy); 
                p.style.left=(w/2)+'px'; 
                p.style.top=(h/3)+'px'; 
                burstBox.appendChild(p);
            } 
            setTimeout(()=>{ burstBox.innerHTML=''; }, 1000); 
        }

        function showCustomAlert(message) {
            const tempModal = document.createElement('div');
            tempModal.className = 'modal';
            tempModal.setAttribute('role', 'alertdialog');
            tempModal.setAttribute('aria-modal', 'true');
            tempModal.innerHTML = `
                <div class="box">
                    <h3 id="customAlertTitle" style="margin:0 0 6px 0">${escapeHTML(message)}</h3>
                    <div class="spacer"></div>
                    <button class="btn primary" id="customAlertOk" type="button">OK</button>
                </div>
            `;
            document.body.appendChild(tempModal);
            tempModal.hidden = false;
            tempModal.classList.add('is-open');
            const okBtn = tempModal.querySelector('#customAlertOk');
            if (okBtn) {
                okBtn.onclick = () => {
                    tempModal.classList.remove('is-open');
                    tempModal.addEventListener('transitionend', function handler() {
                        tempModal.remove();
                        tempModal.removeEventListener('transitionend', handler);
                    }, { once: true });
                };
                okBtn.focus();
            }
        }

        function showCustomConfirm(message, onConfirm) {
            const tempModal = document.createElement('div');
            tempModal.className = 'modal';
            tempModal.setAttribute('role', 'dialog');
            tempModal.setAttribute('aria-modal', 'true');
            tempModal.innerHTML = `
                <div class="box">
                    <h3 id="customConfirmTitle" style="margin:0 0 6px 0">${escapeHTML(message)}</h3>
                    <div class="spacer"></div>
                    <div class="row" style="justify-content:center">
                        <button class="btn warn" id="customConfirmCancel" type="button">Batal</button>
                        <button class="btn primary" id="customConfirmOk" type="button">Ya</button>
                    </div>
                </div>
            `;
            document.body.appendChild(tempModal);
            tempModal.hidden = false;
            tempModal.classList.add('is-open');
            const okBtn = tempModal.querySelector('#customConfirmOk');
            const cancelBtn = tempModal.querySelector('#customConfirmCancel');

            if (okBtn && cancelBtn) {
                okBtn.onclick = () => {
                    tempModal.classList.remove('is-open');
                    tempModal.addEventListener('transitionend', function handler() {
                        tempModal.remove();
                        onConfirm(true);
                        tempModal.removeEventListener('transitionend', handler);
                    }, { once: true });
                };
                cancelBtn.onclick = () => {
                    tempModal.classList.remove('is-open');
                    tempModal.addEventListener('transitionend', function handler() {
                        tempModal.remove();
                        onConfirm(false);
                        tempModal.removeEventListener('transitionend', handler);
                    }, { once: true });
                };
                okBtn.focus();
            }
        }


        // ---------- POMODORO ----------
        let pomoHandle=null;
        function upPomoLabel(){ if (qs('#pomoLabel')) qs('#pomoLabel').textContent = state.pomo.mode==='work'? t('pomo_focus'):t('pomo_break'); }
        function drawRemain(){ const m=String(Math.floor(state.pomo.remaining/60)).padStart(2,'0'); const s=String(state.pomo.remaining%60).padStart(2,'0'); if (qs('#pomoTime')) qs('#pomoTime').textContent=`${m}:${s}`; }
        const fmt = (sec)=>`${String(Math.floor(sec/60)).padStart(2,'0')}:${String(sec%60).padStart(2,'0')}`;

        function startPomo(){
            state.pomo.work = Math.max(1, parseInt(qs('#pomoWork')?.value,10)||25);
            state.pomo.break = Math.max(1, parseInt(qs('#pomoBreak')?.value,10)||5);
            if(!state.pomo.running){
                state.pomo.running=true;
                state.pomo.last=Date.now();
                if(state.pomo.remaining<=0) state.pomo.remaining = state.pomo.work*60;
                showToast(t('pomo_start_focus', fmt(state.pomo.work * 60)), 'info', 3000);
                save();
            }
            tickPomo();
            const interval = state.lite ? 1000 : 250;
            if(!pomoHandle) pomoHandle=setInterval(tickPomo, interval);
        }
        function pausePomo(){ state.pomo.running=false; save(); if(pomoHandle){ clearInterval(pomoHandle); pomoHandle=null; } }
        function resetPomo(){ pausePomo(); state.pomo.mode='work'; state.pomo.remaining = state.pomo.work*60; upPomoLabel(); drawRemain(); save(); }
        function tickPomo(){
            if(!state.pomo.running) return;
            const now=Date.now();
            const dt=Math.floor((now - state.pomo.last)/1000);
            if(dt<=0){ return; }
            state.pomo.last = now;
            state.pomo.remaining = Math.max(0, state.pomo.remaining - dt);
            if(state.pomo.remaining===0){
                clickTone('ok');
                if(state.pomo.mode==='work'){
                    state.pomo.mode='break';
                    state.pomo.remaining=state.pomo.break*60;
                    showToast(t('pomo_time_break'), 'info', 3000);
                } else {
                    state.pomo.mode='work';
                    state.pomo.remaining=state.pomo.work*60;
                    showToast(t('pomo_start_focus', fmt(state.pomo.work * 60)), 'info', 3000);
                }
                upPomoLabel();
            }
            drawRemain();
            save();
        }

        // ---------- NORMALIZATION & CONVERSION ----------
        function hasKana(s){ return /[ぁ-んァ-ン]/.test(s); }
        function normalizeRomaji(v){
            v=(v||'').toLowerCase().trim();
            const alias = {
                si:'shi', ti:'chi', tu:'tsu', hu:'fu', wo:'o',
                di:'dji', du:'dzu',
                ji:'dji', zu:'dzu'
            };
            return alias[v] || v;
        }

        function romajiStringToKana(str,set){
            let s=(str||'').toLowerCase().replace(/\s+/g,'');
            let out='';
            const map = set === 'hira' ? HIRA_MAP : KATA_MAP;

            while(s.length){
                let matched=false;
                if(s[0]==='n'){
                    if(s[1]==='n'){ out += map.get('n'); s=s.slice(2); matched=true; continue; }
                    const next=s[1]||'';
                    if(next && !'aeiouy'.includes(next)){ out += map.get('n'); s=s.slice(1); matched=true; continue; }
                }
                
                for(const r of ROMAJI_SORTED){
                    if(s.startsWith(r)){
                        out += map.get(r);
                        s=s.slice(r.length);
                        matched=true;
                        break;
                    }
                }
                if(!matched){
                    if(/^[bcdfghjklmnpqrstvwxyz]\1/.test(s)){
                        out += (set==='hira'?'っ':'ッ');
                        s = s.slice(1);
                        matched=true;
                        continue;
                    }
                    s=s.slice(1);
                }
            } return out;
        }

        function makeSequence(poolLabels, set, length){
            const src = poolLabels.filter(r => ALL_ROMAJI.includes(r));
            const len = Math.max(2, Math.min(6, length || state.test.sylPerItem || 3));
            const picks=[];
            if (src.length === 0) return { romaji: '', kana: '' };

            for(let i=0;i<len;i++){ const r = src[Math.floor(Math.random()*src.length)]; picks.push(r); }
            const romaji=picks.join('');
            const kana=romajiStringToKana(romaji,set);
            return {romaji,kana};
        }

        function makeKanaSequence(poolLabels, set, length) { // Changed signature to match buildPoolLabels()
            const map = set === 'hira' ? HIRA_MAP : KATA_MAP;
            const availableRomaji = poolLabels.filter(r => map.has(r));
            
            if (availableRomaji.length === 0) return { romaji: '', kana: '' };

            const len = Math.max(2, Math.min(6, length || state.test.sylPerItem || 3));
            let romajiSequence = [];
            let kanaSequence = '';

            for (let i = 0; i < len; i++) {
                const randomRomaji = availableRomaji[Math.floor(Math.random() * availableRomaji.length)];
                romajiSequence.push(randomRomaji);
                kanaSequence += map.get(randomRomaji);
            }
            return { romaji: romajiSequence.join(''), kana: kanaSequence };
        }

        // C. Input discipline (mode ketik = romaji only)
        function enforceInputDiscipline(){
            const input = document.querySelector('#ans'); if(!input) return;
            const qt = (document.querySelector('#qType')?.value || state?.test?.qType || '').toLowerCase();

            input.oninput = (e)=>{
                let v = e.target.value;
                // Untuk k2r/audio_k2r/seq/kseq -> drop semua kana supaya jawaban tetap romaji murni:
                // Menggunakan regex yang lebih inklusif untuk Kana
                if (qt==='k2r' || qt==='audio_k2r' || qt==='seq' || qt==='kseq'){
                    v = v.replace(/[ぁ-んァ-ンー゛゜]/g,'');
                }
                e.target.value = v;
            };
        }


        // ---------- UTILS ----------
        function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
        function attachLongPress(el, onClick, onLong){ let t=null, long=false; const down=()=>{ long=false; t=setTimeout(()=>{ long=true; onLong&&onLong(); }, 500); }; const up=()=>{ clearTimeout(t); if(!long) onClick&&onClick(); }; el.addEventListener('pointerdown', down, {passive:true}); el.addEventListener('pointerup', up, {passive:true}); el.addEventListener('pointerleave', ()=>clearTimeout(t), {passive:true}); el.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); onClick&&onClick(); } }); }

        // ---------- EXPORT / IMPORT PROGRESS ----------
        function sanitizeState(s){
            const clamp = (n,min,max)=> Math.min(max, Math.max(min, Number(n)||0));
            const onlyRomaji = arr => (Array.isArray(arr)? arr.filter(x=>ALL_ROMAJI.includes(x)) : []);

            const safe = {...s};
            safe.hiraMastered = onlyRomaji(safe.hiraMastered);
            safe.kataMastered = onlyRomaji(safe.kataMastered);
            safe.totalPoints = clamp(safe.totalPoints, 0, 1_000_000);
            safe.level = clamp(safe.level, 1, 99);
            
            if (!safe.test) safe.test = {};
            safe.test.target = clamp(safe.test.target, 1, 1000);
            safe.test.sylPerItem = clamp(safe.test.sylPerItem, 2, 6);
            safe.test.rangeFrom = typeof safe.test.rangeFrom === 'string' ? safe.test.rangeFrom : 'aiueo';
            safe.test.rangeTo = typeof safe.test.rangeTo === 'string' ? safe.test.rangeTo : 'n';
            safe.test.singleGroup = typeof safe.test.singleGroup === 'string' ? safe.test.singleGroup : 'aiueo';
            
            if (!safe.pomo) safe.pomo = {};
            safe.pomo.work = clamp(safe.pomo.work, 1, 60);
            safe.pomo.break = clamp(safe.pomo.break, 1, 30);
            safe.pomo.remaining = clamp(safe.pomo.remaining, 0, (safe.pomo.work || 25) * 60);
            
            safe.audio = !!safe.audio;
            safe.pomo.running = !!safe.pomo.running;
            safe.hasSeenOnboarding = !!safe.hasSeenOnboarding;
            safe.lite = !!safe.lite;

            safe.theme = ['pastel', 'hc'].includes(safe.theme) ? safe.theme : 'pastel';
            safe.test.set = ['hira', 'kata'].includes(safe.test.set) ? safe.test.set : 'hira';
            safe.test.mode = ['type', 'mc'].includes(safe.test.mode) ? safe.test.mode : 'type';
            safe.test.qType = ['k2r', 'r2k', 'seq', 'audio_k2r', 'audio_r2k', 'kseq'].includes(safe.test.qType) ? safe.test.qType : 'k2r'; 
            safe.test.rangeMode = ['range', 'single'].includes(safe.test.rangeMode) ? safe.test.rangeMode : 'range';
            safe.test.subset = ['all', ...GROUPS.map(g => g.key), 'confusion', 'srs_due', 'jft-drill'].includes(safe.test.subset) ? safe.test.subset : 'all'; // Updated for JFT Drill

            if (!safe.confusionLog) safe.confusionLog = {hira:{}, kata:{}};
            if (typeof safe.confusionLog.hira !== 'object') safe.confusionLog.hira = {};
            if (typeof safe.confusionLog.kata !== 'object') safe.confusionLog.kata = {};
            for (const setType of ['hira', 'kata']) {
                for (const pair in safe.confusionLog[setType]) {
                    safe.confusionLog[setType][pair] = clamp(safe.confusionLog[setType][pair], 0, 10000);
                }
            }

            if (!safe.srs) safe.srs = {boxes:{}, due:{}};
            if (typeof safe.srs.boxes !== 'object') safe.srs.boxes = {};
            if (typeof safe.srs.due !== 'object') safe.srs.due = {};
            for (const romaji in safe.srs.boxes) {
                safe.srs.boxes[romaji] = clamp(safe.srs.boxes[romaji], 1, 5);
                safe.srs.due[romaji] = clamp(safe.srs.due[romaji], 0, 9999999999);
            }

            return safe;
        }

        function exportProgress(){
            const blob = new Blob([JSON.stringify(sanitizeState(state))], {type:'application/json'});
            const a=document.createElement('a'); a.href=URL.createObjectURL(blob);
            a.download='kana-progress.json'; a.click(); URL.revokeObjectURL(a.href);
            showToast(t('export_ok'));
        }

        function importProgress(file){
            const r=new FileReader();
            r.onload=()=>{
                try{
                    const raw = JSON.parse(r.result);
                    if (raw && typeof raw === 'object') {
                        const s = sanitizeState(raw);
                        localStorage.setItem(KEY, JSON.stringify(s));
                        state = load();
                        renderAll();
                        showToast(t('import_ok'));
                    } else {
                        showToast(t('import_fail'), 'warn');
                    }
                }catch(e){
                    console.error("Error parsing imported file:", e);
                    showToast(t('import_fail'), 'warn');
                }
            };
            r.onerror = (e) => {
                console.error("FileReader error:", e);
                showToast(t('import_fail'), 'warn');
            };
            r.readAsText(file);
        }

        // ---------- ONBOARDING ----------
        function showOnboarding() {
            const onboardingModal = qs('#onboardingModal');
            const mainContent = qs('#main');

            if (state.hasSeenOnboarding) {
                if (onboardingModal) onboardingModal.hidden = true;
                if (mainContent) mainContent.style.display = 'block';
                return;
            }

            if (onboardingModal) onboardingModal.hidden = false;
            if (onboardingModal) onboardingModal.classList.add('is-open');
            _trapModalOnboarding();

            bind('#btnStartLearningOnboarding', 'click', () => {
                state.hasSeenOnboarding = true;
                save();
                if (onboardingModal) {
                    onboardingModal.classList.remove('is-open');
                    onboardingModal.addEventListener('transitionend', function handler() {
                        onboardingModal.hidden = true;
                        onboardingModal.removeEventListener('transitionend', handler);
                    }, { once: true });
                }
                if (mainContent) mainContent.style.display = 'block';
                if (_escCloseListenerOnboarding) {
                    document.removeEventListener('keydown', _escCloseListenerOnboarding);
                    _escCloseListenerOnboarding = null;
                }
            });
        }

        let _escCloseListenerOnboarding = null;
        function _trapModalOnboarding(){
            const onboardingModal = qs('#onboardingModal');
            if (!onboardingModal) return;
            const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
            const focusables = onboardingModal.querySelectorAll(focusableElements);
            const firstFocusable = focusables[0];
            const lastFocusable = focusables[focusables.length - 1];

            onboardingModal.addEventListener('keydown', (e) => {
                const isTabPressed = (e.key === 'Tab' || e.keyCode === 9);
                if (!isTabPressed) return;

                if (e.shiftKey) {
                    if (document.activeElement === firstFocusable) {
                        lastFocusable.focus();
                        e.preventDefault();
                    }
                } else {
                    if (document.activeElement === lastFocusable) {
                        firstFocusable.focus();
                        e.preventDefault();
                    }
                }
            });
            if (!_escCloseListenerOnboarding) {
                _escCloseListenerOnboarding = (e) => {
                    if (e.key === 'Escape') {
                        const btnStartLearning = qs('#btnStartLearningOnboarding');
                        if (btnStartLearning) {
                            btnStartLearning.click();
                        }
                    }
                };
                document.addEventListener('keydown', _escCloseListenerOnboarding);
            }
            firstFocusable?.focus();
        }

        // ---------- LITE MODE ----------
        function applyPerfMode() {
            document.documentElement.setAttribute('data-lite', state.lite ? '1' : '0');
            const liteToggle = qs('#liteToggle');
            if (liteToggle) {
                liteToggle.checked = state.lite;
            }
            if (pomoHandle) {
                clearInterval(pomoHandle);
                pomoHandle = null;
                if (state.pomo.running) {
                    startPomo();
                }
            }
            showToast(state.lite ? t('lite_mode_on') : t('lite_mode_off'));
        }

        // ---------- BINDINGS ----------
        bind('#btnShowLearn', 'click', startLearn);
        bind('#btnStart', 'click', startTest);
        bind('#btnEnd', 'click', endTest);
        bind('#btnSkip', 'click', skipQ);
        bind('#btnCheck', 'click', checkAns);

        // Klik/tap
        on('#optA','click',()=>chooseMC(0));
        on('#optB','click',()=>chooseMC(1));
        on('#optC','click',()=>chooseMC(2));
        on('#optD','click',()=>chooseMC(3));

        // Tambahan pengaman di input agar “r” benar-benar tidak bocor ke listener global:
        on('#ans','keydown',(e)=>{
            // Saat mengetik di input, jangan biarkan keydown bubbling ke listener global
            // supaya hotkey (mis. 'r') tidak pernah tertembak.
            e.stopPropagation();
        });

        // Ganti handler hotkey supaya tidak mengganggu input
        document.addEventListener('keydown', (e) => {
            const tag = (document.activeElement?.tagName || '').toLowerCase();
            const inText = tag === 'input' || tag === 'textarea' || document.activeElement?.isContentEditable;

            // Cek mode jawaban saat ini
            const mode = (qs('#answerMode')?.value || (window.state?.test?.mode) || 'type').toLowerCase();
            const isTypingMode = mode === 'type';

            // --- 1) Lindungi mode KETIK: biarkan semua huruf (termasuk 'r') masuk ke input ---
            if (isTypingMode && inText) {
                // IZINKAN pengetikan normal; JANGAN proses hotkey apa pun di bawah
                // Kecuali: Enter & ArrowRight kita handle di bawah khusus input
            } else {
                // --- 2) Hotkey global hanya saat TIDAK mengetik ---
                // Hotkey Replay (R) — aktif hanya saat TIDAK fokus input & bukan mode ketik
                if (String(e.key).toLowerCase() === 'r') {
                    e.preventDefault();
                    // Panggil fungsi playKanaAudio atau ttsSpeak tergantung konteks
                    const currentKana = (window.currentItem && currentItem.char) 
                                     || (window.currentItem && currentItem.kanaSeq && currentItem.kanaSeq[0]) 
                                     || '';
                    if (currentKana) {
                        playKanaAudio(currentKana);
                    } else {
                        playCurrentQuestionAudio?.(); // Fallback to TTS if no specific kana for audio element
                    }
                    return;
                }

                // MCQ: A/B/C/D atau 1/2/3/4
                if (mode === 'mc') {
                    const k = String(e.key).toLowerCase();
                    const idx = (k==='a'||k==='1')?0:(k==='b'||k==='2')?1:(k==='c'||k==='3')?2:(k==='d'||k==='4')?3:-1;
                    if (idx >= 0) { e.preventDefault(); chooseMC?.(idx); return; }
                }
            }

            // --- 3) Enter & ArrowRight boleh jalan kapan pun sesuai fungsinya ---
            if (e.key === 'Enter' && !(mode === 'mc' && !inText)) {
                // Enter = Cek hanya relevan di mode ketik, dan saat fokus bukan di tombol lain
                const btn = qs('#btnCheck');
                if (btn && isTypingMode && !btn.hidden) { e.preventDefault(); btn.click(); } // Pastikan tombol tidak hidden
                return;
            }
            if (e.key === 'ArrowRight') {
                const skip = qs('#btnSkip'); if (skip) { e.preventDefault(); skip.click(); }
                return;
            }
        }, { passive:false });


        bind('#tPastel', 'click', ()=>{ state.theme='pastel'; save(); applyTheme(); });
        bind('#tHC', 'click', ()=>{ state.theme='hc'; save(); applyTheme(); });
        bind('#audToggle', 'change', (e)=>{ state.audio = e.target.checked; save(); });
        bind('#liteToggle', 'change', (e) => { state.lite = e.target.checked; save(); applyPerfMode(); });

        bind('#resetBtn', 'click', ()=>{
            showCustomConfirm(t('confirm_reset_title'), (confirmed) => {
                if(confirmed){
                    localStorage.removeItem(KEY);
                    state=initState();
                    applyTheme();
                    applyAudio();
                    applyPerfMode();
                    renderAll();
                    save();
                    showToast('Semua progres telah direset.');
                }
            });
        });

        bind('#resetConfusionBtn', 'click', () => {
            showCustomConfirm(t('confirm_reset_title'), (confirmed) => {
                if (confirmed) {
                    state.confusionLog = { hira: {}, kata: {} };
                    save();
                    showToast('Confusion log telah direset.');
                }
            });
        });

        bind('#countChips', 'click', (e)=>{ const b=e.target.closest('.chip'); if(!b) return; const c=parseInt(b.dataset.count,10)||10; if (qs('#testCount')) qs('#testCount').value=c; clickTone('click'); save(); });
        bind('#sylPerItem', 'input', (e) => {
            state.test.sylPerItem = Math.max(2, Math.min(6, parseInt(e.target.value, 10) || 3));
            save();
        });

        bind('#pStart', 'click', startPomo);
        bind('#pPause', 'click', pausePomo);
        bind('#pReset', 'click', resetPomo);

        // Event listener for subset chips (modified to exclude preset chips which have their own click handlers)
        qsa('#subsetChips .chip:not([data-preset])').forEach?.(chip => { // Added optional chaining
            chip.addEventListener('click', (e) => {
                const clickedChip = e.target.closest('.chip');
                if (!clickedChip) return;

                let actualKey = '';
                if (clickedChip.textContent === t('all_kana_label')) {
                    actualKey = 'all';
                } else if (clickedChip.textContent === t('confuse_train_label')) {
                    actualKey = 'confusion';
                } else if (clickedChip.textContent === t('review_today_label')) {
                    actualKey = 'srs_due';
                } else {
                    // Check if the clicked chip corresponds to a group key (e.g., 'a i u e o' for 'aiueo')
                    const foundGroup = GROUPS.find(g => g.label === clickedChip.textContent);
                    if (foundGroup) {
                        actualKey = foundGroup.key;
                    }
                }

                if (actualKey) {
                    state.test.subset = actualKey;
                    // If a subset chip is selected, update rangeMode accordingly
                    // 'all', 'confusion', 'srs_due', 'jft-drill' are special cases (logic handled in getChosenSubset)
                    // Group chips should implicitly set rangeMode to 'single'
                    if (actualKey === 'all' || actualKey === 'confusion' || actualKey === 'srs_due' || actualKey === 'jft-drill') {
                        state.test.rangeMode = 'range'; // These implicitly use a "range" logic for selection
                    } else if (GROUPS.some(g => g.key === actualKey)) {
                        state.test.rangeMode = 'single';
                        state.test.singleGroup = actualKey; // Also set the single group
                        if (elSingle) elSingle.value = actualKey; // Update UI for single group
                    } else {
                        // If it's not a special chip or a group chip, clear subset and default to range
                        state.test.subset = '';
                        state.test.rangeMode = 'range';
                    }
                    save();
                    buildSubsetChips(); // Rebuild to update active state
                    updateRangeUI(); // Apply range mode logic after subset change
                    updateTestInfo(); // Update test info text
                    clickTone('click');
                } else {
                     // If no actualKey found, it means it's likely a preset that's not 'jft-drill'
                    // For presets like 'aiueo-m', we want to clear the subset to enable range controls.
                    if (clickedChip.dataset.preset && clickedChip.dataset.preset !== 'jft-drill') {
                        state.test.subset = '';
                        save();
                        buildSubsetChips();
                        updateRangeUI();
                        updateTestInfo();
                        clickTone('click');
                    }
                }
            });
        });
        
        // Bind click handlers for the new preset chips
        qsa('#subsetChips .chip[data-preset]').forEach?.(ch=>{ // Added optional chaining
            ch.addEventListener('click', ()=>applyPreset(ch.dataset.preset));
        });


        bind('#answerMode', 'change', (e) => { 
            state.test.mode = e.target.value; 
            save(); 
            // Panggil applyAnswerModeUI() untuk sinkronisasi tampilan
            applyAnswerModeUI(); 
            updateTestInfo(); // Update test info text
        });
        bind('#qType', 'change', (e) => { 
            state.test.qType = e.target.value; 
            save(); 
            toggleAnswerUI(); 
            const sylControl = qs('#sylPerItemControl');
            if (sylControl) {
                sylControl.hidden = !(state.test.qType === 'seq' || state.test.qType === 'kseq');
            }
            updateTestInfo(); // Update test info text
        });

        // Hubungkan ke tombol 🔊 (sekali saja) - kini menggunakan .btn-audio-current
        // Logic ini sekarang berada di `bindAudioButtonToCurrent()` yang dipanggil di `afterRenderQuestion`

        bind('#exportBtn', 'click', exportProgress);
        bind('#importBtn', 'click', () => { qs('#importFile')?.click(); });
        bind('#importFile', 'change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                importProgress(e.target.files[0]);
                e.target.value = null;
            }
        });

        // Sidebar functions - now integrated with router
        function toggleSidebar() {
            const sidebar = qs('#sidebar');
            const body = qs('body');
            if (sidebar && body) {
                sidebar.classList.toggle('is-open');
                body.classList.toggle('sidebar-open');
            }
        }

        function closeSidebar() {
            const sidebar = qs('#sidebar');
            const body = qs('body');
            if (sidebar && body) {
                sidebar.classList.remove('is-open');
                body.classList.remove('sidebar-open');
            }
        }

        // Sinkron UI Mode (Ketik vs MC)
        function applyAnswerModeUI(){
            const mode = (qs('#answerMode')?.value || window.state?.test?.mode || 'type').toLowerCase();
            const typeWrap = qs('#typeWrap');
            const mcWrap = qs('#mcWrap');
            if (!typeWrap || !mcWrap) return;
            const isMC = mode === 'mc';
            typeWrap.hidden = isMC;
            mcWrap.hidden = !isMC;
        }
        on('#answerMode','change',()=>{
            window.state.test.mode = qs('#answerMode').value;
            typeof save === 'function' && save();
            applyAnswerModeUI();
        });


        // Removed old scrollToSection, replaced by router

        // ---------- RENDER ----------
        function renderAll(){
            buildKana('hiraBox','hira');
            buildKana('kataBox','kata');
            buildSubsetChips(); // Re-added
            fillLearnRange();
            populateRangeSelects();
            // Ensure state.test.rangeMode is set before calling updateRangeUI
            // It should be set during load() or initState(), but explicit safety check
            if (!state.test.rangeMode && elRangeMode) {
                state.test.rangeMode = elRangeMode.value;
                save();
            }
            updateRangeUI(); // Initial call to updateRangeUI

            renderStats();
            applyTheme();
            applyAudio();
            applyPerfMode();
            upPomoLabel();
            if(!state.pomo.remaining) state.pomo.remaining=state.pomo.work*60;
            drawRemain();
            if (qs('#pomoWork')) qs('#pomoWork').value=state.pomo.work;
            if (qs('#pomoBreak')) qs('#pomoBreak').value=state.pomo.break;
            // Set values without affecting width
            const testCountInput = qs('#testCount');
            if (testCountInput) testCountInput.value = state.test.target || 10;
            const sylPerItemInput = qs('#sylPerItem');
            if (sylPerItemInput) sylPerItemInput.value = state.test.sylPerItem;

            toggleAnswerUI();
            updatePointsAndLevelDisplay();
            updateTestInfo(); // Initial update of test info text
            applyAnswerModeUI(); // panggil saat mulai tes & tiap render soal
        }

        document.addEventListener('DOMContentLoaded', ()=>{
            const deviceMemory = navigator.deviceMemory || 0;
            const hardwareConcurrency = navigator.hardwareConcurrency || 0;
            if (!state.hasSeenOnboarding && (deviceMemory < 4 || hardwareConcurrency <= 4)) {
                state.lite = true;
                save();
            }

            renderAll();
            if(state.pomo.running){ startPomo(); }
            showOnboarding();
            setInterval(renderStats, 5000);

            bind('#sidebarToggle', 'click', toggleSidebar);
            bind('#closeSidebar', 'click', closeSidebar);
            // Close sidebar when any link inside it is clicked
            qsa('#sidebar .menu a').forEach(link => {
                link.addEventListener('click', closeSidebar);
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && qs('#sidebar')?.classList.contains('is-open')) {
                    closeSidebar();
                }
            });

            // --- NEW JS ROUTER ---
            // PAGES now reference actual HTML files for full page reloads
            const PAGES = ["index.html","index2.html","index3.html","index4.html","index5.html","index6.html","index7.html"]; // Added index7.html
            const $menu  = document.querySelectorAll('#sidebar [href]');

            // Active state for sidebar links
            $menu.forEach(a=>{
                // Compare current pathname with link href
                const currentPath = location.pathname.split('/').pop() || 'index.html'; // Default to index.html if root
                const linkPath = a.getAttribute('href').split('/').pop();

                if(currentPath === linkPath){
                    a.classList.add('active');
                } else {
                    a.classList.remove('active');
                }
            });

            // For the main page (index.html), ensure the content is shown
            const mainContent = qs('#main');
            if (mainContent) {
                // The display logic for #main is now primarily handled by showOnboarding().
                // Keeping this as a fallback if showOnboarding doesn't run or has issues.
                mainContent.style.display = 'block';
            }
            // --- END NEW JS ROUTER ---

            // Disable/enable start button based on test count
            const btnStart = qs('#btnStart');
            const testCountInput = qs('#testCount');
            function updateStartButtonState() {
                if (btnStart && testCountInput) {
                    btnStart.disabled = (parseInt(testCountInput.value, 10) <= 0);
                }
            }
            testCountInput?.addEventListener('input', updateStartButtonState);
            updateStartButtonState(); // Initial check
        });
    </script>
</body>
</html>
